/**
 * Core batch builder implementation
 *
 * @remarks
 * Provides a stateful builder for composing batches of blockchain operations.
 * Operations can be added manually or via templates, validated, and exported.
 *
 * **Design Principles:**
 * - Single Responsibility: Builder manages operation collection and validation only
 * - Immutability: Operations are value objects, builder creates new instances
 * - Type Safety: Comprehensive type checking with no implicit any types
 * - Validation First: All operations validated before export or execution
 *
 * @category Batch Builder
 * @module builder
 */

import type { Address } from "viem";
import { getAddress } from "viem";
import type { Network, AuditResults } from "../types";
import type {
  Batch,
  BatchOperation,
  BatchValidationResult,
  OperationType,
} from "./builder-types";

/**
 * Input for creating a new operation
 *
 * @remarks
 * Omits `id` which is auto-generated by the builder.
 * Omits `execution` which is only populated during execution.
 */
export type CreateOperationInput = Omit<BatchOperation, "id" | "execution">;

/**
 * Stateful builder for composing batches of operations
 *
 * @remarks
 * Manages a collection of operations with add/remove/validate capabilities.
 * Does not handle execution - that is the responsibility of the execution engine.
 *
 * **Usage Pattern:**
 * ```typescript
 * const builder = new BatchBuilder("mainnet", "My Batch");
 *
 * // Add operations
 * const opId = builder.addOperation({
 *   type: "revoke",
 *   contract: { address: "0x...", name: "DataRegistry" },
 *   method: "revokeRole",
 *   parameters: { role: "0x...", account: "0x..." }
 * });
 *
 * // Validate
 * const validation = builder.validate();
 * if (!validation.valid) {
 *   console.error(validation.errors);
 * }
 *
 * // Export
 * const batch = builder.toBatch();
 * ```
 *
 * @category Batch Builder
 */
export class BatchBuilder {
  private batchId: string;
  private readonly network: Network;
  private batchName: string;
  private batchDescription?: string;
  private operations: BatchOperation[];
  private createdAt: number;
  private createdBy?: Address;

  /**
   * Creates a new batch builder
   *
   * @param network - Target network for the batch
   * @param name - Human-readable batch name
   * @param description - Optional detailed description
   */
  constructor(network: Network, name: string, description?: string) {
    this.batchId = this.generateId();
    this.network = network;
    this.batchName = name;
    this.batchDescription = description;
    this.operations = [];
    this.createdAt = Date.now();
  }

  /**
   * Generates a unique identifier
   *
   * @remarks
   * Uses crypto.randomUUID() for RFC 4122 compliant UUIDs.
   * Falls back to timestamp-based ID in environments without crypto API.
   *
   * @internal
   */
  private generateId(): string {
    if (typeof crypto !== "undefined" && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback for environments without crypto.randomUUID
    return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  }

  /**
   * Gets the batch ID
   */
  public getId(): string {
    return this.batchId;
  }

  /**
   * Gets the network
   */
  public getNetwork(): Network {
    return this.network;
  }

  /**
   * Gets the batch name
   */
  public getName(): string {
    return this.batchName;
  }

  /**
   * Sets the batch name
   *
   * @param name - New batch name
   */
  public setName(name: string): void {
    this.batchName = name;
  }

  /**
   * Gets the batch description
   */
  public getDescription(): string | undefined {
    return this.batchDescription;
  }

  /**
   * Sets the batch description
   *
   * @param description - New description
   */
  public setDescription(description: string | undefined): void {
    this.batchDescription = description;
  }

  /**
   * Sets the creator address
   *
   * @remarks
   * Should be called when wallet is connected to track batch origin.
   *
   * @param address - Wallet address that created the batch
   */
  public setCreatedBy(address: Address): void {
    this.createdBy = address;
  }

  /**
   * Adds a single operation to the batch
   *
   * @remarks
   * Generates a unique ID for the operation and adds it to the collection.
   * Operations are stored in insertion order.
   *
   * @param input - Operation definition (without id or execution state)
   * @returns The generated operation ID for reference
   *
   * @example
   * ```typescript
   * const opId = builder.addOperation({
   *   type: "revoke",
   *   contract: { address: "0x123...", name: "DataRegistry" },
   *   method: "revokeRole",
   *   parameters: { role: "0xabc...", account: "0xdef..." },
   *   metadata: { roleLabel: "ADMIN_ROLE" }
   * });
   * ```
   */
  public addOperation(input: CreateOperationInput): string {
    const id = this.generateId();
    const operation: BatchOperation = {
      id,
      ...input,
    };
    this.operations.push(operation);
    return id;
  }

  /**
   * Adds multiple operations to the batch
   *
   * @remarks
   * Convenience method for adding operations in bulk, typically from templates.
   * Maintains insertion order.
   *
   * @param inputs - Array of operation definitions
   * @returns Array of generated operation IDs in the same order
   *
   * @example
   * ```typescript
   * const operations = revokeAllTemplate(params, network);
   * const ids = builder.addOperations(operations);
   * console.log(`Added ${ids.length} operations`);
   * ```
   */
  public addOperations(inputs: CreateOperationInput[]): string[] {
    return inputs.map((input) => this.addOperation(input));
  }

  /**
   * Removes an operation by ID
   *
   * @remarks
   * No-op if the operation ID doesn't exist. Returns boolean indicating
   * whether an operation was actually removed.
   *
   * @param id - Operation ID to remove
   * @returns True if operation was removed, false if ID not found
   */
  public removeOperation(id: string): boolean {
    const index = this.operations.findIndex((op) => op.id === id);
    if (index === -1) return false;
    this.operations.splice(index, 1);
    return true;
  }

  /**
   * Removes multiple operations by ID
   *
   * @param ids - Array of operation IDs to remove
   * @returns Number of operations actually removed
   */
  public removeOperations(ids: string[]): number {
    let removed = 0;
    for (const id of ids) {
      if (this.removeOperation(id)) {
        removed++;
      }
    }
    return removed;
  }

  /**
   * Gets a single operation by ID
   *
   * @param id - Operation ID
   * @returns The operation, or undefined if not found
   */
  public getOperation(id: string): BatchOperation | undefined {
    return this.operations.find((op) => op.id === id);
  }

  /**
   * Gets all operations in the batch
   *
   * @remarks
   * Returns operations in insertion order. Returns a new array to prevent
   * external modification of internal state.
   *
   * @returns Array of all operations
   */
  public getOperations(): BatchOperation[] {
    return [...this.operations];
  }

  /**
   * Gets the number of operations in the batch
   */
  public getOperationCount(): number {
    return this.operations.length;
  }

  /**
   * Clears all operations from the batch
   *
   * @remarks
   * Removes all operations but preserves batch metadata (name, description).
   */
  public clear(): void {
    this.operations = [];
  }

  /**
   * Checks if the batch is empty
   */
  public isEmpty(): boolean {
    return this.operations.length === 0;
  }

  /**
   * Filters operations by type
   *
   * @param type - Operation type to filter by
   * @returns Array of operations matching the type
   */
  public getOperationsByType(type: OperationType): BatchOperation[] {
    return this.getOperations().filter((op) => op.type === type);
  }

  /**
   * Filters operations by contract
   *
   * @param contractAddress - Contract address to filter by
   * @returns Array of operations for the specified contract
   */
  public getOperationsByContract(contractAddress: Address): BatchOperation[] {
    return this.getOperations().filter(
      (op) =>
        op.contract.address.toLowerCase() === contractAddress.toLowerCase(),
    );
  }

  /**
   * Validates the batch
   *
   * @remarks
   * Performs comprehensive validation including:
   * - Empty batch detection
   * - Duplicate operation detection
   * - Parameter validation
   * - Conflict detection (grant + revoke same role)
   * - Orphaned contract detection (no admin after execution)
   *
   * Does not throw - returns result object with errors and warnings.
   *
   * @param auditResults - Optional current audit state for post-execution validation
   * @returns Validation result with errors and warnings
   *
   * @example
   * ```typescript
   * const validation = builder.validate(auditResults);
   * if (!validation.valid) {
   *   validation.errors.forEach(err => console.error(err.message));
   * }
   * validation.warnings.forEach(warn => console.warn(warn.message));
   * ```
   */
  public validate(auditResults?: AuditResults): BatchValidationResult {
    const errors: BatchValidationResult["errors"] = [];
    const warnings: BatchValidationResult["warnings"] = [];

    // Check if batch is empty
    if (this.isEmpty()) {
      errors.push({
        code: "E100",
        message: "Batch is empty. Add at least one operation.",
      });
      return { valid: false, errors, warnings };
    }

    // Check for duplicate operations
    const seen = new Set<string>();
    const operations = this.getOperations();

    for (const op of operations) {
      // Create unique key from operation definition
      const key = `${op.contract.address.toLowerCase()}:${op.method}:${JSON.stringify(op.parameters)}`;

      if (seen.has(key)) {
        warnings.push({
          code: "W001",
          message: `Duplicate operation: ${op.method} on ${op.contract.name}`,
          operationIds: [op.id],
        });
      }
      seen.add(key);

      // Validate parameters are non-empty
      if (Object.keys(op.parameters).length === 0) {
        errors.push({
          code: "E101",
          message: `Operation ${op.id} has no parameters`,
          operationId: op.id,
        });
      }
    }

    // Detect conflicts: grant and revoke of same role to same account
    this.detectConflicts(operations, warnings);

    // Check for orphaned contracts (no admin after execution)
    if (auditResults) {
      this.detectOrphanedContracts(operations, auditResults, errors);
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Detects conflicting operations
   *
   * @remarks
   * Identifies operations that conflict, such as granting and revoking
   * the same role to the same account. Adds warnings to the result.
   *
   * @param operations - Operations to check
   * @param warnings - Array to append warnings to
   * @internal
   */
  private detectConflicts(
    operations: BatchOperation[],
    warnings: BatchValidationResult["warnings"],
  ): void {
    // Build map of grant/revoke pairs
    const roleOps = new Map<string, { grants: string[]; revokes: string[] }>();

    for (const op of operations) {
      if (op.method === "grantRole" || op.method === "revokeRole") {
        const role = op.parameters.role;
        const account = op.parameters.account;
        const key = `${op.contract.address.toLowerCase()}:${role}:${account}`;

        if (!roleOps.has(key)) {
          roleOps.set(key, { grants: [], revokes: [] });
        }

        const entry = roleOps.get(key)!;
        if (op.method === "grantRole") {
          entry.grants.push(op.id);
        } else {
          entry.revokes.push(op.id);
        }
      }
    }

    // Check for conflicts
    for (const [key, { grants, revokes }] of roleOps) {
      if (grants.length > 0 && revokes.length > 0) {
        const [contractAddr, role, account] = key.split(":");
        const contract = operations.find(
          (op) => op.contract.address.toLowerCase() === contractAddr,
        )?.contract.name;

        warnings.push({
          code: "W002",
          message: `Conflicting operations: granting and revoking same role (${role.slice(0, 10)}...) for account ${account.slice(0, 8)}... on ${contract}`,
          operationIds: [...grants, ...revokes],
        });
      }
    }
  }

  /**
   * Detects contracts that would have no admin after batch execution
   *
   * @remarks
   * Simulates batch execution on current state and checks if any contract
   * will have zero DEFAULT_ADMIN_ROLE holders. This prevents accidentally
   * bricking contracts by removing all admins.
   *
   * @param operations - Operations to simulate
   * @param auditResults - Current audit state
   * @param errors - Array to append errors to
   * @internal
   */
  private detectOrphanedContracts(
    operations: BatchOperation[],
    auditResults: AuditResults,
    errors: BatchValidationResult["errors"],
  ): void {
    const DEFAULT_ADMIN_ROLE =
      "0x0000000000000000000000000000000000000000000000000000000000000000";

    // Get all unique contracts affected by this batch
    const affectedContracts = new Set<string>();
    for (const op of operations) {
      affectedContracts.add(op.contract.address.toLowerCase());
    }

    // For each contract, simulate post-execution state
    for (const contractAddr of affectedContracts) {
      // Get current DEFAULT_ADMIN_ROLE holders from audit
      const currentAdmins = new Set<string>(
        auditResults.currentState
          .filter(
            (entry) =>
              entry.contractAddress.toLowerCase() === contractAddr &&
              entry.roleHash === DEFAULT_ADMIN_ROLE,
          )
          .map((entry) => getAddress(entry.address).toLowerCase()),
      );

      // Apply batch operations to simulate final state
      for (const op of operations) {
        if (
          op.contract.address.toLowerCase() === contractAddr &&
          op.parameters.role === DEFAULT_ADMIN_ROLE
        ) {
          const account = getAddress(op.parameters.account).toLowerCase();
          if (op.type === "grant") {
            currentAdmins.add(account);
          } else if (op.type === "revoke") {
            currentAdmins.delete(account);
          }
        }
      }

      // Check if contract will have zero admins
      if (currentAdmins.size === 0) {
        const contractName =
          operations.find(
            (op) => op.contract.address.toLowerCase() === contractAddr,
          )?.contract.name ?? contractAddr;

        errors.push({
          code: "E200",
          message: `CRITICAL: ${contractName} will have NO admins after execution. Contract would be bricked.`,
        });
      }
    }
  }

  /**
   * Converts builder state to a Batch object
   *
   * @remarks
   * Creates an immutable snapshot of the current batch state.
   * Use this to persist the batch or pass to execution engine.
   *
   * @returns Complete batch definition
   */
  public toBatch(): Batch {
    return {
      id: this.batchId,
      name: this.batchName,
      description: this.batchDescription,
      network: this.network,
      operations: this.getOperations(),
      createdAt: this.createdAt,
      updatedAt: Date.now(),
      createdBy: this.createdBy,
    };
  }

  /**
   * Creates a builder from an existing batch
   *
   * @remarks
   * Allows editing a previously created batch. Preserves original batch ID
   * and creation timestamp.
   *
   * @param batch - Existing batch to load
   * @returns New builder instance with batch data loaded
   */
  /**
   * Moves an operation up one position
   *
   * @param id - Operation ID to move
   * @returns True if moved, false if already at top or not found
   */
  public moveOperationUp(id: string): boolean {
    const index = this.operations.findIndex((op) => op.id === id);
    if (index <= 0) return false; // Already at top or not found

    // Swap with previous
    [this.operations[index - 1], this.operations[index]] = [
      this.operations[index],
      this.operations[index - 1],
    ];
    return true;
  }

  /**
   * Moves an operation down one position
   *
   * @param id - Operation ID to move
   * @returns True if moved, false if already at bottom or not found
   */
  public moveOperationDown(id: string): boolean {
    const index = this.operations.findIndex((op) => op.id === id);
    if (index === -1 || index === this.operations.length - 1) return false;

    // Swap with next
    [this.operations[index], this.operations[index + 1]] = [
      this.operations[index + 1],
      this.operations[index],
    ];
    return true;
  }

  /**
   * Moves an operation to a specific index
   *
   * @param id - Operation ID to move
   * @param newIndex - Target index (0-based)
   * @returns True if moved, false if invalid
   */
  public moveOperationToIndex(id: string, newIndex: number): boolean {
    const currentIndex = this.operations.findIndex((op) => op.id === id);
    if (currentIndex === -1) return false;
    if (newIndex < 0 || newIndex >= this.operations.length) return false;
    if (currentIndex === newIndex) return true; // Already there

    // Remove from current position
    const [operation] = this.operations.splice(currentIndex, 1);
    // Insert at new position
    this.operations.splice(newIndex, 0, operation);
    return true;
  }

  public static fromBatch(batch: Batch): BatchBuilder {
    const builder = new BatchBuilder(
      batch.network,
      batch.name,
      batch.description,
    );
    // Override auto-generated ID with existing ID
    builder.batchId = batch.id;
    builder.createdAt = batch.createdAt;
    builder.createdBy = batch.createdBy;

    // Add all operations in order
    builder.operations = batch.operations.map((op) => ({ ...op }));

    return builder;
  }
}
