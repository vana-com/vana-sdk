/**
 * Core batch generation logic for address rotation
 * Generates Safe Transaction Builder compatible JSON files
 */
import { getAddress } from "viem";
import type { Address } from "viem";
import type { Network, AuditResults } from "../types";
import { getAuditableContracts, KNOWN_ROLES } from "../../config/contracts";
import { getAddressLabel } from "../../config";
import { validateRotationInput } from "./validation";
import type {
  RotationFormInput,
  SafeBatchFile,
  SafeTransaction,
  BatchGenerationResult,
} from "./types";
import { GRANT_ROLE_METHOD, REVOKE_ROLE_METHOD } from "./types";

/**
 * Get chain ID for network
 * CRITICAL: Must return STRING not number for Safe compatibility
 */
function getChainId(network: Network): string {
  return network === "mainnet" ? "1480" : "14800";
}

/**
 * Create a grantRole transaction
 * All addresses MUST be checksummed via getAddress()
 */
function createGrantRoleTransaction(
  contractAddress: Address,
  roleHash: string,
  account: Address,
): SafeTransaction {
  return {
    to: getAddress(contractAddress), // Ensure checksum
    value: "0",
    data: null,
    contractMethod: GRANT_ROLE_METHOD,
    contractInputsValues: {
      role: roleHash,
      account: getAddress(account), // Ensure checksum
    },
  };
}

/**
 * Create a revokeRole transaction
 * All addresses MUST be checksummed via getAddress()
 */
function createRevokeRoleTransaction(
  contractAddress: Address,
  roleHash: string,
  account: Address,
): SafeTransaction {
  return {
    to: getAddress(contractAddress), // Ensure checksum
    value: "0",
    data: null,
    contractMethod: REVOKE_ROLE_METHOD,
    contractInputsValues: {
      role: roleHash,
      account: getAddress(account), // Ensure checksum
    },
  };
}

/**
 * Generate human-readable batch name
 */
function generateBatchName(
  input: RotationFormInput,
  _network: Network,
): string {
  const roleName = input.role
    ? (KNOWN_ROLES[input.role] ?? "Role")
    : "All Roles";

  // Get labels if available
  const oldLabel = getAddressLabel(input.oldAddress);
  const newLabel = getAddressLabel(input.newAddress);

  const oldDisplay =
    oldLabel ??
    `${input.oldAddress.slice(0, 6)}...${input.oldAddress.slice(-4)}`;
  const newDisplay =
    newLabel ??
    `${input.newAddress.slice(0, 6)}...${input.newAddress.slice(-4)}`;

  return `Rotate ${roleName}: ${oldDisplay} â†’ ${newDisplay}`;
}

/**
 * Generate detailed batch description
 */
function generateBatchDescription(
  input: RotationFormInput,
  transactionCount: number,
  contractCount: number,
  _network: Network,
): string {
  const roleName = input.role ? KNOWN_ROLES[input.role] : "all roles";
  const date = new Date().toISOString().split("T")[0]; // YYYY-MM-DD

  return `Grant ${roleName} to ${input.newAddress} and revoke from ${input.oldAddress} across ${contractCount} contracts (${transactionCount} transactions). Generated by Vana RBAC Auditor on ${date}.`;
}

/**
 * Get all roles to rotate
 * Priority order:
 * 1. If specific role provided, use that
 * 2. If audit results available, find roles the old address currently has
 * 3. Fallback: all known roles from SDK
 */
function getRolesToRotate(
  roleHash: string | undefined,
  oldAddress: Address,
  auditResults?: AuditResults,
): string[] {
  if (roleHash) {
    // Specific role selected - use it
    return [roleHash];
  }

  // "All roles" selected - try to use audit results
  if (auditResults) {
    // Find roles this address currently has from audit
    const normalizedOldAddress = getAddress(oldAddress).toLowerCase();
    const activeRoles = auditResults.currentState
      .filter(
        (entry) =>
          getAddress(entry.address).toLowerCase() === normalizedOldAddress,
      )
      .map((entry) => entry.roleHash);

    // Deduplicate and return
    const uniqueRoles = [...new Set(activeRoles)];

    if (uniqueRoles.length > 0) {
      return uniqueRoles;
    }
  }

  // Fallback: all known roles from SDK
  // This happens when no audit results or address has no roles
  return Object.keys(KNOWN_ROLES);
}

/**
 * Generate rotation batch
 *
 * Algorithm:
 * 1. Validate inputs (3 checks)
 * 2. Determine contracts to process (all or filtered)
 * 3. Determine roles to rotate (specific or all)
 * 4. Generate transactions (grant-first order):
 *    - For each contract:
 *      - For each role:
 *        - grantRole(role, newAddress)
 *        - revokeRole(role, oldAddress)
 * 5. Build Safe JSON
 *
 * @param input - Form inputs
 * @param network - Target network
 * @param auditResults - Optional audit results for smart role discovery
 * @returns Batch generation result
 */
export function generateRotationBatch(
  input: RotationFormInput,
  network: Network,
  auditResults?: AuditResults,
): BatchGenerationResult {
  // Step 1: Validate inputs
  const validation = validateRotationInput(input);
  if (!validation.isValid) {
    return {
      success: false,
      errors: validation.errors,
    };
  }

  // Step 2: Determine contracts to process
  let contracts = getAuditableContracts(network);

  if (input.contractAddresses && input.contractAddresses.length > 0) {
    // Filter to specified contracts
    const selectedAddresses = input.contractAddresses.map((addr) =>
      getAddress(addr).toLowerCase(),
    );

    contracts = contracts.filter((contract) =>
      selectedAddresses.includes(contract.address.toLowerCase()),
    );
  }

  if (contracts.length === 0) {
    return {
      success: false,
      errors: [
        {
          code: "E004",
          field: "contractAddresses",
          message: "No contracts selected",
        },
      ],
    };
  }

  // Step 3: Determine roles to rotate
  const roles = getRolesToRotate(input.role, input.oldAddress, auditResults);

  // Step 4: Generate transactions (grant-first order)
  const transactions: SafeTransaction[] = [];

  for (const contract of contracts) {
    for (const roleHash of roles) {
      // Grant first (safer - prevents permission gaps)
      transactions.push(
        createGrantRoleTransaction(
          contract.address,
          roleHash,
          input.newAddress,
        ),
      );

      // Then revoke
      transactions.push(
        createRevokeRoleTransaction(
          contract.address,
          roleHash,
          input.oldAddress,
        ),
      );
    }
  }

  // Step 5: Build Safe JSON
  const batch: SafeBatchFile = {
    version: "1.0",
    chainId: getChainId(network),
    createdAt: Date.now(),
    meta: {
      name: generateBatchName(input, network),
      description: generateBatchDescription(
        input,
        transactions.length,
        contracts.length,
        network,
      ),
      txBuilderVersion: "1.16.5",
      createdFromSafeAddress: "",
      createdFromOwnerAddress: "",
      checksum: "",
    },
    transactions,
  };

  return {
    success: true,
    batch,
    transactionCount: transactions.length,
  };
}

/**
 * Discover which roles will be rotated (for UI preview)
 * Same logic as getRolesToRotate but exported for UI use
 *
 * @param oldAddress - Address to rotate from
 * @param roleHash - Specific role hash, or undefined for all roles
 * @param auditResults - Optional audit results
 * @returns Array of role hashes that will be rotated
 */
export function discoverRolesToRotate(
  oldAddress: Address,
  roleHash?: string,
  auditResults?: AuditResults,
): string[] {
  return getRolesToRotate(roleHash, oldAddress, auditResults);
}

/**
 * Download batch as JSON file
 *
 * @param batch - Safe batch file
 * @param network - Network name for filename
 */
export function downloadBatch(batch: SafeBatchFile, network: Network): void {
  const date = new Date().toISOString().split("T")[0]; // YYYY-MM-DD
  const filename = `batch-rotate-${date}-${network}.json`;

  const json = JSON.stringify(batch, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const link = document.createElement("a");
  link.href = url;
  link.download = filename;
  link.click();

  // Cleanup
  URL.revokeObjectURL(url);
}
