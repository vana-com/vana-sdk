import { describe, it, expect } from "vitest";
import { BrowserPlatformAdapter } from "../platform/browser";
import { NodePlatformAdapter } from "../platform/node";

/**
 * Cross-platform cryptographic compatibility tests
 *
 * These tests verify that keys generated by one platform adapter
 * can be used successfully by another platform adapter, ensuring
 * full secp256k1 compatibility across browser and Node.js environments.
 */
describe("Cross-Platform Crypto Compatibility", () => {
  describe("secp256k1 Key Generation Compatibility", () => {
    it("should generate secp256k1 keys that work across platforms", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Generate a key pair using the browser adapter
      const browserKeyPair = await browserAdapter.crypto.generateKeyPair();

      // Generate a key pair using the node adapter
      const nodeKeyPair = await nodeAdapter.crypto.generateKeyPair();

      // Verify that both key pairs have the expected format
      expect(browserKeyPair.publicKey).toMatch(/^[0-9a-fA-F]+$/);
      expect(browserKeyPair.privateKey).toMatch(/^[0-9a-fA-F]+$/);
      expect(nodeKeyPair.publicKey).toMatch(/^[0-9a-fA-F]+$/);
      expect(nodeKeyPair.privateKey).toMatch(/^[0-9a-fA-F]+$/);

      // Verify compressed public keys are the correct length (33 bytes = 66 hex chars)
      expect(browserKeyPair.publicKey).toHaveLength(66);
      expect(nodeKeyPair.publicKey).toHaveLength(66);

      // Verify private keys are the correct length (32 bytes = 64 hex chars)
      expect(browserKeyPair.privateKey).toHaveLength(64);
      expect(nodeKeyPair.privateKey).toHaveLength(64);
    });

    it("should encrypt with browser-generated public key and decrypt with node adapter", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Generate key pair using browser adapter
      const keyPair = await browserAdapter.crypto.generateKeyPair();
      const testMessage = "Hello from browser key to node decryption!";

      // Encrypt using node adapter with browser-generated public key
      const encrypted = await nodeAdapter.crypto.encryptWithWalletPublicKey(
        testMessage,
        keyPair.publicKey,
      );

      // Decrypt using browser adapter with browser-generated private key
      const decrypted = await browserAdapter.crypto.decryptWithWalletPrivateKey(
        encrypted,
        keyPair.privateKey,
      );

      expect(decrypted).toBe(testMessage);
    });

    it("should encrypt with node-generated public key and decrypt with browser adapter", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Generate key pair using node adapter
      const keyPair = await nodeAdapter.crypto.generateKeyPair();
      const testMessage = "Hello from node key to browser decryption!";

      // Encrypt using browser adapter with node-generated public key
      const encrypted = await browserAdapter.crypto.encryptWithWalletPublicKey(
        testMessage,
        keyPair.publicKey,
      );

      // Decrypt using node adapter with node-generated private key
      const decrypted = await nodeAdapter.crypto.decryptWithWalletPrivateKey(
        encrypted,
        keyPair.privateKey,
      );

      expect(decrypted).toBe(testMessage);
    });

    it("should handle cross-platform encryption/decryption with full round-trip", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Test data
      const testMessages = [
        "Simple message",
        "Message with special characters: !@#$%^&*()",
        "Unicode message: 🔐🌍🚀",
        "Long message: " + "A".repeat(1000),
        JSON.stringify({ data: "complex", nested: { value: 42 } }),
      ];

      for (const message of testMessages) {
        // Test Browser Key → Node Encrypt → Browser Decrypt
        const browserKeyPair = await browserAdapter.crypto.generateKeyPair();
        const encryptedByNode =
          await nodeAdapter.crypto.encryptWithWalletPublicKey(
            message,
            browserKeyPair.publicKey,
          );
        const decryptedByBrowser =
          await browserAdapter.crypto.decryptWithWalletPrivateKey(
            encryptedByNode,
            browserKeyPair.privateKey,
          );
        expect(decryptedByBrowser).toBe(message);

        // Test Node Key → Browser Encrypt → Node Decrypt
        const nodeKeyPair = await nodeAdapter.crypto.generateKeyPair();
        const encryptedByBrowser =
          await browserAdapter.crypto.encryptWithWalletPublicKey(
            message,
            nodeKeyPair.publicKey,
          );
        const decryptedByNode =
          await nodeAdapter.crypto.decryptWithWalletPrivateKey(
            encryptedByBrowser,
            nodeKeyPair.privateKey,
          );
        expect(decryptedByNode).toBe(message);
      }
    });

    it("should verify that generated keys follow secp256k1 format", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Generate multiple key pairs to verify consistency
      const browserKeys = await Promise.all([
        browserAdapter.crypto.generateKeyPair(),
        browserAdapter.crypto.generateKeyPair(),
        browserAdapter.crypto.generateKeyPair(),
      ]);

      const nodeKeys = await Promise.all([
        nodeAdapter.crypto.generateKeyPair(),
        nodeAdapter.crypto.generateKeyPair(),
        nodeAdapter.crypto.generateKeyPair(),
      ]);

      // Verify all browser-generated keys follow secp256k1 format
      for (const keyPair of browserKeys) {
        // Compressed public key should start with 02 or 03
        expect(keyPair.publicKey).toMatch(/^0[23][0-9a-fA-F]{64}$/);
        // Private key should be 32 bytes (64 hex chars)
        expect(keyPair.privateKey).toMatch(/^[0-9a-fA-F]{64}$/);
      }

      // Verify all node-generated keys follow secp256k1 format
      for (const keyPair of nodeKeys) {
        // Compressed public key should start with 02 or 03
        expect(keyPair.publicKey).toMatch(/^0[23][0-9a-fA-F]{64}$/);
        // Private key should be 32 bytes (64 hex chars)
        expect(keyPair.privateKey).toMatch(/^[0-9a-fA-F]{64}$/);
      }

      // Verify keys are unique
      const allPublicKeys = [...browserKeys, ...nodeKeys].map(
        (k) => k.publicKey,
      );
      const uniquePublicKeys = new Set(allPublicKeys);
      expect(uniquePublicKeys.size).toBe(allPublicKeys.length);
    });
  });

  describe("Regression Tests", () => {
    it("should maintain compatibility with existing wallet encryption workflow", async () => {
      const browserAdapter = new BrowserPlatformAdapter();
      const nodeAdapter = new NodePlatformAdapter();

      // Simulate the typical workflow:
      // 1. Browser generates a key pair
      // 2. Public key is shared for encryption
      // 3. Data is encrypted (potentially on server/node)
      // 4. Encrypted data is sent back to browser for decryption

      const browserKeyPair = await browserAdapter.crypto.generateKeyPair();
      const sensitiveData = "User's private information";

      // Simulate server-side encryption with user's public key
      const encryptedOnServer =
        await nodeAdapter.crypto.encryptWithWalletPublicKey(
          sensitiveData,
          browserKeyPair.publicKey,
        );

      // Simulate client-side decryption with user's private key
      const decryptedOnClient =
        await browserAdapter.crypto.decryptWithWalletPrivateKey(
          encryptedOnServer,
          browserKeyPair.privateKey,
        );

      expect(decryptedOnClient).toBe(sensitiveData);
    });

    it("should handle edge cases and malformed inputs gracefully", async () => {
      const browserAdapter = new BrowserPlatformAdapter();

      // Test with invalid public key formats
      await expect(
        browserAdapter.crypto.encryptWithWalletPublicKey("test", "invalid-key"),
      ).rejects.toThrow();

      // Test with invalid private key formats
      await expect(
        browserAdapter.crypto.decryptWithWalletPrivateKey(
          "test",
          "invalid-key",
        ),
      ).rejects.toThrow();

      // Test with empty strings
      await expect(
        browserAdapter.crypto.encryptWithWalletPublicKey("test", ""),
      ).rejects.toThrow();

      await expect(
        browserAdapter.crypto.decryptWithWalletPrivateKey("test", ""),
      ).rejects.toThrow();
    });
  });
});
