import { describe, it, expect, vi } from "vitest";
import { generateEncryptionKey, encryptUserData, decryptUserData, generatePGPKeyPair } from "../utils/encryption";
import { BrowserPlatformAdapter } from "../platform/browser";
import { withConsole } from "./setup";

// Mock wallet for testing
const mockWallet = {
  account: { address: "0x123456789abcdef" },
  signMessage: vi.fn(),
};

describe("Demo Page Encryption Integration", () => {
  it("should fail when using wallet signature as PGP key", withConsole(async () => {
    // This test reproduces the exact error from the demo page
    const platformAdapter = new BrowserPlatformAdapter();
    
    // Mock generateEncryptionKey to return a wallet signature (simulating real behavior)
    mockWallet.signMessage.mockResolvedValue("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef");
    
    const walletSignature = await generateEncryptionKey(
      mockWallet as any,
      "test-seed"
    );
    
    console.log("Generated wallet signature:", walletSignature);
    
    const testData = new Blob(["test data"], { type: "text/plain" });
    
    // This should fail with "Misformed armored text" error  
    try {
      const result = await encryptUserData(testData, walletSignature, platformAdapter);
      console.log("Unexpected success - encryption result:", result);
      expect.fail("Expected encryption to fail but it succeeded");
    } catch (error) {
      console.log("Caught expected error:", (error as Error).message);
      expect(error).toBeInstanceOf(Error);
      expect((error as Error).message).toContain("PGP encryption failed");
    }
  }));

  it("should succeed when using proper PGP key", async () => {
    // This test shows the correct approach
    const platformAdapter = new BrowserPlatformAdapter();
    
    // Generate proper PGP key pair
    const keyPair = await generatePGPKeyPair(platformAdapter, {
      name: "Test User",
      email: "test@example.com"
    });
    
    const testData = new Blob(["test data"], { type: "text/plain" });
    
    // This should succeed
    const encrypted = await encryptUserData(testData, keyPair.publicKey, platformAdapter);
    expect(encrypted).toBeInstanceOf(Blob);
    const encryptedText = await encrypted.text();
    expect(encryptedText).toContain("-----BEGIN PGP MESSAGE-----");
  });

  it("should generate PGP key pair with default options", async () => {
    const platformAdapter = new BrowserPlatformAdapter();
    
    // Test generating key pair without options
    const keyPair = await generatePGPKeyPair(platformAdapter);
    
    expect(keyPair).toHaveProperty('publicKey');
    expect(keyPair).toHaveProperty('privateKey');
    expect(keyPair.publicKey).toContain("-----BEGIN PGP PUBLIC KEY BLOCK-----");
    expect(keyPair.privateKey).toContain("-----BEGIN PGP PRIVATE KEY BLOCK-----");
  });

  it("should round-trip encrypt and decrypt properly", async () => {
    const platformAdapter = new BrowserPlatformAdapter();
    
    // Generate proper PGP key pair
    const keyPair = await generatePGPKeyPair(platformAdapter, {
      name: "Round Trip Test",
      email: "roundtrip@test.com"
    });
    
    const originalData = "This is test data for round-trip encryption";
    const testData = new Blob([originalData], { type: "text/plain" });
    
    // Encrypt the data
    const encrypted = await encryptUserData(testData, keyPair.publicKey, platformAdapter);
    expect(encrypted).toBeInstanceOf(Blob);
    
    // Decrypt the data
    const decrypted = await decryptUserData(encrypted, keyPair.privateKey, platformAdapter);
    expect(decrypted).toBeInstanceOf(Blob);
    
    const decryptedText = await decrypted.text();
    expect(decryptedText).toBe(originalData);
  });
});