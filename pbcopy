diff --git a/package-lock.json b/package-lock.json
index 6cd075f..aca321e 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -7368,6 +7368,13 @@
         "url": "https://github.com/chalk/ansi-styles?sponsor=1"
       }
     },
+    "node_modules/any-promise": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
+      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/anymatch": {
       "version": "3.1.3",
       "license": "ISC",
@@ -7883,6 +7890,22 @@
         "node": ">=6.14.2"
       }
     },
+    "node_modules/bundle-require": {
+      "version": "5.1.0",
+      "resolved": "https://registry.npmjs.org/bundle-require/-/bundle-require-5.1.0.tgz",
+      "integrity": "sha512-3WrrOuZiyaaZPWiEt4G3+IffISVC9HYlWueJEBWED4ZH4aIAC2PnkdnuRrR94M+w6yGWn4AglWtJtBI8YqvgoA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "load-tsconfig": "^0.2.3"
+      },
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      },
+      "peerDependencies": {
+        "esbuild": ">=0.18"
+      }
+    },
     "node_modules/busboy": {
       "version": "1.6.0",
       "dev": true,
@@ -8253,6 +8276,23 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/confbox": {
+      "version": "0.1.8",
+      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz",
+      "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==",
+      "dev": true,
+      "license": "MIT"
+    },
+    "node_modules/consola": {
+      "version": "3.4.2",
+      "resolved": "https://registry.npmjs.org/consola/-/consola-3.4.2.tgz",
+      "integrity": "sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^14.18.0 || >=16.10.0"
+      }
+    },
     "node_modules/convert-source-map": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
@@ -10120,6 +10160,18 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/fix-dts-default-cjs-exports": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/fix-dts-default-cjs-exports/-/fix-dts-default-cjs-exports-1.0.1.tgz",
+      "integrity": "sha512-pVIECanWFC61Hzl2+oOCtoJ3F17kglZC/6N94eRWycFgBH35hHx0Li604ZIzhseh97mf2p0cv7vVrOZGoqhlEg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "magic-string": "^0.30.17",
+        "mlly": "^1.7.4",
+        "rollup": "^4.34.8"
+      }
+    },
     "node_modules/flat": {
       "version": "5.0.2",
       "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
@@ -11218,6 +11270,16 @@
         "jiti": "lib/jiti-cli.mjs"
       }
     },
+    "node_modules/joycon": {
+      "version": "3.1.1",
+      "resolved": "https://registry.npmjs.org/joycon/-/joycon-3.1.1.tgz",
+      "integrity": "sha512-34wB/Y7MW7bzjKRjUKTa46I2Z7eV62Rkhva+KkopW7Qvv/OSWBqvkSY7vusOPrNuZcUG3tApvdVgNB8POj3SPw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=10"
+      }
+    },
     "node_modules/js-sha3": {
       "version": "0.8.0",
       "resolved": "https://registry.npmjs.org/js-sha3/-/js-sha3-0.8.0.tgz",
@@ -11453,6 +11515,13 @@
         "url": "https://github.com/sponsors/antonk52"
       }
     },
+    "node_modules/lines-and-columns": {
+      "version": "1.2.4",
+      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
+      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/linkify-it": {
       "version": "5.0.0",
       "dev": true,
@@ -11528,6 +11597,16 @@
         "@types/trusted-types": "^2.0.2"
       }
     },
+    "node_modules/load-tsconfig": {
+      "version": "0.2.5",
+      "resolved": "https://registry.npmjs.org/load-tsconfig/-/load-tsconfig-0.2.5.tgz",
+      "integrity": "sha512-IXO6OCs9yg8tMKzfPZ1YmheJbZCiEsnBdcB03l0OcfK9prKnJb96siuHCr5Fl37/yo9DnKU+TLpxzTUspw9shg==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
+      }
+    },
     "node_modules/locate-path": {
       "version": "6.0.0",
       "dev": true,
@@ -11554,6 +11633,13 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/lodash.sortby": {
+      "version": "4.7.0",
+      "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
+      "integrity": "sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/log-update": {
       "version": "6.1.0",
       "dev": true,
@@ -11877,6 +11963,19 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/mlly": {
+      "version": "1.7.4",
+      "resolved": "https://registry.npmjs.org/mlly/-/mlly-1.7.4.tgz",
+      "integrity": "sha512-qmdSIPC4bDJXgZTCR7XosJiNKySV7O215tsPtDN9iEO/7q/76b/ijtgRu/+epFXSJhijtTCCGp3DWS549P3xKw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "acorn": "^8.14.0",
+        "pathe": "^2.0.1",
+        "pkg-types": "^1.3.0",
+        "ufo": "^1.5.4"
+      }
+    },
     "node_modules/modern-ahocorasick": {
       "version": "1.1.0",
       "license": "MIT"
@@ -11908,6 +12007,18 @@
       "version": "9.9.0",
       "license": "(Apache-2.0 AND MIT)"
     },
+    "node_modules/mz": {
+      "version": "2.7.0",
+      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
+      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "any-promise": "^1.0.0",
+        "object-assign": "^4.0.1",
+        "thenify-all": "^1.0.0"
+      }
+    },
     "node_modules/nan": {
       "version": "2.14.0",
       "resolved": "https://registry.npmjs.org/nan/-/nan-2.14.0.tgz",
@@ -12575,6 +12686,28 @@
       "version": "4.0.0",
       "license": "MIT"
     },
+    "node_modules/pirates": {
+      "version": "4.0.7",
+      "resolved": "https://registry.npmjs.org/pirates/-/pirates-4.0.7.tgz",
+      "integrity": "sha512-TfySrs/5nm8fQJDcBDuUng3VOUKsd7S+zqvbOTiGXHfxX4wK31ard+hoNuvkicM/2YFzlpDgABOevKSsB4G/FA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/pkg-types": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.3.1.tgz",
+      "integrity": "sha512-/Jm5M4RvtBFVkKWRu2BLUTNP8/M2a+UwuAX+ae4770q1qVGtfjG+WTCupoZixokjmHiry8uI+dlY8KXYV5HVVQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "confbox": "^0.1.8",
+        "mlly": "^1.7.4",
+        "pathe": "^2.0.1"
+      }
+    },
     "node_modules/pngjs": {
       "version": "5.0.0",
       "license": "MIT",
@@ -12623,6 +12756,49 @@
         "node": "^10 || ^12 || >=14"
       }
     },
+    "node_modules/postcss-load-config": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-6.0.1.tgz",
+      "integrity": "sha512-oPtTM4oerL+UXmx+93ytZVN82RrlY/wPUV8IeDxFrzIjXOLF1pN+EmKPLbubvKHT2HC20xXsCAH2Z+CKV6Oz/g==",
+      "dev": true,
+      "funding": [
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/postcss/"
+        },
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
+      "license": "MIT",
+      "dependencies": {
+        "lilconfig": "^3.1.1"
+      },
+      "engines": {
+        "node": ">= 18"
+      },
+      "peerDependencies": {
+        "jiti": ">=1.21.0",
+        "postcss": ">=8.0.9",
+        "tsx": "^4.8.1",
+        "yaml": "^2.4.2"
+      },
+      "peerDependenciesMeta": {
+        "jiti": {
+          "optional": true
+        },
+        "postcss": {
+          "optional": true
+        },
+        "tsx": {
+          "optional": true
+        },
+        "yaml": {
+          "optional": true
+        }
+      }
+    },
     "node_modules/postcss-value-parser": {
       "version": "4.2.0",
       "dev": true,
@@ -13695,6 +13871,19 @@
         "atomic-sleep": "^1.0.0"
       }
     },
+    "node_modules/source-map": {
+      "version": "0.8.0-beta.0",
+      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.8.0-beta.0.tgz",
+      "integrity": "sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==",
+      "dev": true,
+      "license": "BSD-3-Clause",
+      "dependencies": {
+        "whatwg-url": "^7.0.0"
+      },
+      "engines": {
+        "node": ">= 8"
+      }
+    },
     "node_modules/source-map-js": {
       "version": "1.2.1",
       "dev": true,
@@ -13703,6 +13892,35 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/source-map/node_modules/tr46": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz",
+      "integrity": "sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "punycode": "^2.1.0"
+      }
+    },
+    "node_modules/source-map/node_modules/webidl-conversions": {
+      "version": "4.0.2",
+      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz",
+      "integrity": "sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==",
+      "dev": true,
+      "license": "BSD-2-Clause"
+    },
+    "node_modules/source-map/node_modules/whatwg-url": {
+      "version": "7.1.0",
+      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz",
+      "integrity": "sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "lodash.sortby": "^4.7.0",
+        "tr46": "^1.0.1",
+        "webidl-conversions": "^4.0.2"
+      }
+    },
     "node_modules/split-on-first": {
       "version": "1.1.0",
       "license": "MIT",
@@ -14063,6 +14281,93 @@
         }
       }
     },
+    "node_modules/sucrase": {
+      "version": "3.35.0",
+      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.35.0.tgz",
+      "integrity": "sha512-8EbVDiu9iN/nESwxeSxDKe0dunta1GOlHufmSSXxMD2z2/tMZpDMpvXQGsc+ajGo8y2uYUmixaSRUc/QPoQ0GA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "@jridgewell/gen-mapping": "^0.3.2",
+        "commander": "^4.0.0",
+        "glob": "^10.3.10",
+        "lines-and-columns": "^1.1.6",
+        "mz": "^2.7.0",
+        "pirates": "^4.0.1",
+        "ts-interface-checker": "^0.1.9"
+      },
+      "bin": {
+        "sucrase": "bin/sucrase",
+        "sucrase-node": "bin/sucrase-node"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.17"
+      }
+    },
+    "node_modules/sucrase/node_modules/commander": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
+      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">= 6"
+      }
+    },
+    "node_modules/sucrase/node_modules/glob": {
+      "version": "10.4.5",
+      "resolved": "https://registry.npmjs.org/glob/-/glob-10.4.5.tgz",
+      "integrity": "sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==",
+      "dev": true,
+      "license": "ISC",
+      "dependencies": {
+        "foreground-child": "^3.1.0",
+        "jackspeak": "^3.1.2",
+        "minimatch": "^9.0.4",
+        "minipass": "^7.1.2",
+        "package-json-from-dist": "^1.0.0",
+        "path-scurry": "^1.11.1"
+      },
+      "bin": {
+        "glob": "dist/esm/bin.mjs"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
+    "node_modules/sucrase/node_modules/jackspeak": {
+      "version": "3.4.3",
+      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
+      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "@isaacs/cliui": "^8.0.2"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      },
+      "optionalDependencies": {
+        "@pkgjs/parseargs": "^0.11.0"
+      }
+    },
+    "node_modules/sucrase/node_modules/path-scurry": {
+      "version": "1.11.1",
+      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
+      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
+      "dev": true,
+      "license": "BlueOak-1.0.0",
+      "dependencies": {
+        "lru-cache": "^10.2.0",
+        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
+      },
+      "engines": {
+        "node": ">=16 || 14 >=14.18"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/isaacs"
+      }
+    },
     "node_modules/superstruct": {
       "version": "1.0.4",
       "license": "MIT",
@@ -14237,6 +14542,29 @@
         "url": "https://github.com/sponsors/isaacs"
       }
     },
+    "node_modules/thenify": {
+      "version": "3.3.1",
+      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
+      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "any-promise": "^1.0.0"
+      }
+    },
+    "node_modules/thenify-all": {
+      "version": "1.6.0",
+      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
+      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "thenify": ">= 3.1.0 < 4"
+      },
+      "engines": {
+        "node": ">=0.8"
+      }
+    },
     "node_modules/thread-stream": {
       "version": "0.15.2",
       "license": "MIT",
@@ -14356,6 +14684,16 @@
       "version": "0.0.3",
       "license": "MIT"
     },
+    "node_modules/tree-kill": {
+      "version": "1.2.2",
+      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
+      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
+      "dev": true,
+      "license": "MIT",
+      "bin": {
+        "tree-kill": "cli.js"
+      }
+    },
     "node_modules/ts-api-utils": {
       "version": "2.1.0",
       "dev": true,
@@ -14367,6 +14705,13 @@
         "typescript": ">=4.8.4"
       }
     },
+    "node_modules/ts-interface-checker": {
+      "version": "0.1.13",
+      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
+      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
+      "dev": true,
+      "license": "Apache-2.0"
+    },
     "node_modules/tsconfck": {
       "version": "3.1.6",
       "resolved": "https://registry.npmjs.org/tsconfck/-/tsconfck-3.1.6.tgz",
@@ -15728,6 +16073,7 @@
         "ajv": "^8.17.1",
         "ajv-formats": "^3.0.1",
         "eccrypto": "^1.1.6",
+        "eccrypto-js": "^5.4.0",
         "openpgp": "^6.1.1",
         "viem": "^2.31.7"
       },
@@ -15743,6 +16089,7 @@
         "globals": "^16.3.0",
         "prettier": "^3.5.3",
         "rimraf": "^6.0.1",
+        "tsup": "^8.5.0",
         "tsx": "^4.19.4",
         "typescript": "^5.8.3",
         "vitest": "^3.2.4"
@@ -15772,6 +16119,69 @@
       "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
       "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
       "license": "MIT"
+    },
+    "packages/vana-sdk/node_modules/resolve-from": {
+      "version": "5.0.0",
+      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-5.0.0.tgz",
+      "integrity": "sha512-qYg9KP24dD5qka9J47d0aVky0N+b4fTU89LN9iDnjB5waksiC49rvMB0PrUJQGoTmH50XPiqOvAjDfaijGxYZw==",
+      "dev": true,
+      "license": "MIT",
+      "engines": {
+        "node": ">=8"
+      }
+    },
+    "packages/vana-sdk/node_modules/tsup": {
+      "version": "8.5.0",
+      "resolved": "https://registry.npmjs.org/tsup/-/tsup-8.5.0.tgz",
+      "integrity": "sha512-VmBp77lWNQq6PfuMqCHD3xWl22vEoWsKajkF8t+yMBawlUS8JzEI+vOVMeuNZIuMML8qXRizFKi9oD5glKQVcQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "bundle-require": "^5.1.0",
+        "cac": "^6.7.14",
+        "chokidar": "^4.0.3",
+        "consola": "^3.4.0",
+        "debug": "^4.4.0",
+        "esbuild": "^0.25.0",
+        "fix-dts-default-cjs-exports": "^1.0.0",
+        "joycon": "^3.1.1",
+        "picocolors": "^1.1.1",
+        "postcss-load-config": "^6.0.1",
+        "resolve-from": "^5.0.0",
+        "rollup": "^4.34.8",
+        "source-map": "0.8.0-beta.0",
+        "sucrase": "^3.35.0",
+        "tinyexec": "^0.3.2",
+        "tinyglobby": "^0.2.11",
+        "tree-kill": "^1.2.2"
+      },
+      "bin": {
+        "tsup": "dist/cli-default.js",
+        "tsup-node": "dist/cli-node.js"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "peerDependencies": {
+        "@microsoft/api-extractor": "^7.36.0",
+        "@swc/core": "^1",
+        "postcss": "^8.4.12",
+        "typescript": ">=4.5.0"
+      },
+      "peerDependenciesMeta": {
+        "@microsoft/api-extractor": {
+          "optional": true
+        },
+        "@swc/core": {
+          "optional": true
+        },
+        "postcss": {
+          "optional": true
+        },
+        "typescript": {
+          "optional": true
+        }
+      }
     }
   }
 }
diff --git a/packages/vana-sdk/package.json b/packages/vana-sdk/package.json
index 2dc1844..40b8b8a 100644
--- a/packages/vana-sdk/package.json
+++ b/packages/vana-sdk/package.json
@@ -3,49 +3,44 @@
   "version": "1.0.9",
   "description": "A TypeScript library for interacting with Vana Network smart contracts.",
   "type": "module",
-  "main": "dist/index.js",
-  "types": "dist/index.d.ts",
+  "main": "dist/index.node.js",
+  "types": "dist/index.node.d.ts",
   "exports": {
     ".": {
       "node": {
-        "types": "./dist/index.d.ts",
+        "types": "./dist/index.node.d.ts",
         "import": "./dist/index.node.js",
         "require": "./dist/index.node.cjs"
       },
       "browser": {
-        "types": "./dist/index.d.ts",
+        "types": "./dist/index.browser.d.ts",
         "import": "./dist/index.browser.js",
         "require": "./dist/index.browser.cjs"
       },
       "default": {
-        "types": "./dist/index.d.ts",
-        "import": "./dist/index.js"
+        "types": "./dist/index.node.d.ts",
+        "import": "./dist/index.node.js"
       }
     },
     "./platform": {
-      "node": {
-        "types": "./dist/platform/node.d.ts",
-        "import": "./dist/platform/node.js",
-        "require": "./dist/platform/node.cjs"
-      },
-      "browser": {
-        "types": "./dist/platform/browser.d.ts",
-        "import": "./dist/platform/browser.js",
-        "require": "./dist/platform/browser.cjs"
-      },
-      "default": "./dist/platform/index.js"
+      "types": "./dist/platform.d.ts",
+      "import": "./dist/platform.js",
+      "require": "./dist/platform.cjs"
     },
     "./chains": {
-      "types": "./dist/config/chains.d.ts",
-      "import": "./dist/config/chains.js"
+      "types": "./dist/chains.d.ts",
+      "import": "./dist/chains.js",
+      "require": "./dist/chains.cjs"
     },
     "./types": {
       "types": "./dist/types.d.ts",
-      "import": "./dist/types.js"
+      "import": "./dist/types.js",
+      "require": "./dist/types.cjs"
     },
     "./errors": {
       "types": "./dist/errors.d.ts",
-      "import": "./dist/errors.js"
+      "import": "./dist/errors.js",
+      "require": "./dist/errors.cjs"
     }
   },
   "files": [
@@ -54,11 +49,7 @@
     "LICENSE"
   ],
   "scripts": {
-    "build": "rimraf dist && npm run build:main && npm run build:node && npm run build:browser && npm run build:setup",
-    "build:main": "tsc",
-    "build:node": "tsc --project tsconfig.node.json",
-    "build:browser": "tsc --project tsconfig.browser.json",
-    "build:setup": "node scripts/setup-builds.cjs",
+    "build": "tsup",
     "clean": "rimraf dist",
     "lint": "eslint .",
     "lint:fix": "eslint . --fix",
@@ -98,6 +89,7 @@
     "globals": "^16.3.0",
     "prettier": "^3.5.3",
     "rimraf": "^6.0.1",
+    "tsup": "^8.5.0",
     "tsx": "^4.19.4",
     "typescript": "^5.8.3",
     "vitest": "^3.2.4"
diff --git a/packages/vana-sdk/src/controllers/data.ts b/packages/vana-sdk/src/controllers/data.ts
index d9ed6a7..7ef8913 100644
--- a/packages/vana-sdk/src/controllers/data.ts
+++ b/packages/vana-sdk/src/controllers/data.ts
@@ -256,7 +256,7 @@ export class DataController {
         Number((b.addedAtTimestamp || 0n) - (a.addedAtTimestamp || 0n)),
       );
 
-      console.warn(`Found ${userFiles.length} files owned by user:`, owner);
+      // Successfully retrieved user files
       return userFiles;
     } catch (error) {
       console.error("Failed to fetch user files from subgraph:", error);
@@ -376,10 +376,7 @@ export class DataController {
         }))
         .sort((a, b) => Number(b.addedAtTimestamp - a.addedAtTimestamp)); // Latest first
 
-      console.warn(
-        `Found ${permissions.length} permissions granted by user:`,
-        user,
-      );
+      // Successfully retrieved user permissions
       return permissions;
     } catch (error) {
       console.error("Failed to fetch user permissions from subgraph:", error);
@@ -475,7 +472,7 @@ export class DataController {
 
       const userData = result.data?.user;
       if (!userData || !userData.trustedServers?.length) {
-        console.warn("No trusted servers found for user:", user);
+        // No trusted servers found for user
         return [];
       }
 
@@ -490,10 +487,7 @@ export class DataController {
         }))
         .sort((a, b) => Number(b.trustedAt - a.trustedAt)); // Latest first
 
-      console.warn(
-        `Found ${trustedServers.length} trusted servers for user:`,
-        user,
-      );
+      // Successfully retrieved trusted servers
       return trustedServers;
     } catch (error) {
       console.error(
@@ -849,7 +843,7 @@ export class DataController {
 
       // Step 2: Fetch the encrypted file from the URL
       const fetchUrl = this.convertIpfsUrl(file.url);
-      console.warn(`ðŸ” Fetching file from: ${file.url} -> ${fetchUrl}`);
+      // Fetching file from storage
 
       const response = await fetch(fetchUrl);
       if (!response.ok) {
@@ -876,7 +870,7 @@ export class DataController {
       }
 
       // Step 3: Decrypt the file using the canonical Vana decryption method
-      const decryptedBlob = await decryptUserData(encryptedBlob, encryptionKey);
+      const decryptedBlob = await decryptUserData(encryptedBlob, encryptionKey, this.context.platform);
 
       return decryptedBlob;
     } catch (error) {
@@ -1494,7 +1488,7 @@ export class DataController {
       );
 
       // 2. Encrypt data with user's key
-      const encryptedData = await encryptUserData(data, userEncryptionKey);
+      const encryptedData = await encryptUserData(data, userEncryptionKey, this.context.platform);
 
       // 3. Upload the encrypted file
       if (!this.context.storageManager) {
@@ -1518,6 +1512,7 @@ export class DataController {
           const encryptedKey = await encryptWithWalletPublicKey(
             userEncryptionKey,
             permission.publicKey,
+            this.context.platform,
           );
           return {
             account: permission.account,
@@ -1588,6 +1583,7 @@ export class DataController {
       const encryptedKey = await encryptWithWalletPublicKey(
         userEncryptionKey,
         publicKey,
+        this.context.platform,
       );
 
       // 3. Add permission to the file
@@ -1716,6 +1712,7 @@ export class DataController {
       const userEncryptionKey = await decryptWithWalletPrivateKey(
         encryptedKey,
         privateKey,
+        this.context.platform,
       );
 
       // 3. Download the encrypted file
@@ -1729,6 +1726,7 @@ export class DataController {
       const decryptedData = await decryptUserData(
         encryptedData,
         userEncryptionKey,
+        this.context.platform,
       );
 
       return decryptedData;
diff --git a/packages/vana-sdk/src/controllers/permissions.ts b/packages/vana-sdk/src/controllers/permissions.ts
index bfd8a19..9f0bdd9 100644
--- a/packages/vana-sdk/src/controllers/permissions.ts
+++ b/packages/vana-sdk/src/controllers/permissions.ts
@@ -36,6 +36,7 @@ import {
 } from "../utils/grantFiles";
 import { validateGrant } from "../utils/grantValidation";
 import { StorageManager } from "../storage";
+import type { VanaPlatformAdapter } from "../platform/interface";
 
 interface SubgraphPermissionsResponse {
   data?: {
@@ -98,6 +99,8 @@ export interface ControllerContext {
   storageManager?: StorageManager;
   /** Optional subgraph URL for querying user files and permissions */
   subgraphUrl?: string;
+  /** Platform adapter for environment-specific operations */
+  platform: VanaPlatformAdapter;
 }
 
 /**
@@ -812,11 +815,8 @@ export class PermissionsController {
             const grantFile = await retrieveGrantFile(permission.grant);
             operation = grantFile.operation;
             parameters = grantFile.parameters;
-          } catch (error) {
-            console.warn(
-              `Failed to retrieve grant file for permission ${permission.id}:`,
-              error,
-            );
+          } catch {
+            // Failed to retrieve grant file - using basic permission data
             // Continue with basic permission data even if grant file can't be retrieved
           }
 
@@ -826,11 +826,8 @@ export class PermissionsController {
               BigInt(permission.id),
             );
             files = fileIds.map((id) => Number(id));
-          } catch (error) {
-            console.warn(
-              `Failed to retrieve file IDs for permission ${permission.id}:`,
-              error,
-            );
+          } catch {
+            // Failed to retrieve file IDs - using empty array
             // Continue with empty files array
           }
 
@@ -846,8 +843,8 @@ export class PermissionsController {
             grantedAt: Number(permission.addedAtBlock),
             nonce: Number(permission.nonce),
           });
-        } catch (error) {
-          console.warn(`Failed to process permission ${permission.id}:`, error);
+        } catch {
+          // Failed to process permission - skipping
         }
       }
 
diff --git a/packages/vana-sdk/src/index.browser.ts b/packages/vana-sdk/src/index.browser.ts
index 46a01cf..45389fa 100644
--- a/packages/vana-sdk/src/index.browser.ts
+++ b/packages/vana-sdk/src/index.browser.ts
@@ -1,17 +1,39 @@
+import { VanaSDKCore } from "./core";
+import { BrowserPlatformAdapter } from "./platform/browser";
+import type { VanaConfig } from "./types";
+
 /**
- * Browser-specific entry point for Vana SDK
- *
- * This entry point ensures that the browser platform adapter is used
- * when the SDK is imported in browser environments.
+ * The Vana SDK class pre-configured for browser environments.
+ * Automatically uses the browser platform adapter.
  */
+export class VanaSDK extends VanaSDKCore {
+  constructor(config: VanaConfig) {
+    // Automatically inject the browser platform adapter
+    super(config, new BrowserPlatformAdapter());
+  }
 
-// Re-export all public APIs from the main index
-export * from "./index";
+  /**
+   * Creates a Vana SDK instance from a chain configuration.
+   * @param config - Chain configuration object
+   * @returns Vana SDK instance configured for browser
+   */
+  static override fromChain(config: VanaConfig) {
+    return new VanaSDK(config);
+  }
 
-// Override the platform adapter getter to use the browser adapter
-import { browserPlatformAdapter } from "./platform/browser";
-import * as platformModule from "./platform";
+  /**
+   * Creates a Vana SDK instance from a wallet client configuration.
+   * @param config - Wallet client configuration object
+   * @returns Vana SDK instance configured for browser
+   */
+  static override fromWallet(config: VanaConfig) {
+    return new VanaSDK(config);
+  }
+}
+
+// Re-export everything from the main index for backwards compatibility
+export * from "./index";
 
-// Monkey patch the getPlatformAdapter function to always return the browser adapter
-(platformModule as Record<string, unknown>).getPlatformAdapter = () =>
-  browserPlatformAdapter;
+// Re-export the SDK as both named and default export
+export { VanaSDK as Vana };
+export default VanaSDK;
\ No newline at end of file
diff --git a/packages/vana-sdk/src/index.node.ts b/packages/vana-sdk/src/index.node.ts
index abc9eba..aa5a06c 100644
--- a/packages/vana-sdk/src/index.node.ts
+++ b/packages/vana-sdk/src/index.node.ts
@@ -1,17 +1,39 @@
+import { VanaSDKCore } from "./core";
+import { NodePlatformAdapter } from "./platform/node";
+import type { VanaConfig } from "./types";
+
 /**
- * Node.js-specific entry point for Vana SDK
- *
- * This entry point ensures that the Node.js platform adapter is used
- * when the SDK is imported in Node.js environments.
+ * The Vana SDK class pre-configured for Node.js environments.
+ * Automatically uses the Node.js platform adapter.
  */
+export class VanaSDK extends VanaSDKCore {
+  constructor(config: VanaConfig) {
+    // Automatically inject the Node.js platform adapter
+    super(config, new NodePlatformAdapter());
+  }
 
-// Re-export all public APIs from the main index
-export * from "./index";
+  /**
+   * Creates a Vana SDK instance from a chain configuration.
+   * @param config - Chain configuration object
+   * @returns Vana SDK instance configured for Node.js
+   */
+  static override fromChain(config: VanaConfig) {
+    return new VanaSDK(config);
+  }
 
-// Override the platform adapter getter to use the Node.js adapter
-import { nodePlatformAdapter } from "./platform/node";
-import * as platformModule from "./platform";
+  /**
+   * Creates a Vana SDK instance from a wallet client configuration.
+   * @param config - Wallet client configuration object
+   * @returns Vana SDK instance configured for Node.js
+   */
+  static override fromWallet(config: VanaConfig) {
+    return new VanaSDK(config);
+  }
+}
+
+// Re-export everything from the main index for backwards compatibility
+export * from "./index";
 
-// Monkey patch the getPlatformAdapter function to always return the Node.js adapter
-(platformModule as Record<string, unknown>).getPlatformAdapter = () =>
-  nodePlatformAdapter;
+// Re-export the SDK as both named and default export
+export { VanaSDK as Vana };
+export default VanaSDK;
\ No newline at end of file
diff --git a/packages/vana-sdk/src/platform/browser.ts b/packages/vana-sdk/src/platform/browser.ts
index c3044fc..bd3e5c4 100644
--- a/packages/vana-sdk/src/platform/browser.ts
+++ b/packages/vana-sdk/src/platform/browser.ts
@@ -5,6 +5,7 @@
  * to provide crypto, PGP, and HTTP functionality without Node.js dependencies.
  */
 
+import * as openpgp from "openpgp";
 import {
   VanaPlatformAdapter,
   VanaCryptoAdapter,
@@ -12,54 +13,183 @@ import {
   VanaHttpAdapter,
 } from "./interface";
 
+// Browser-native crypto implementation using Web Crypto API
+class BrowserECDH {
+  async generateKeyPair() {
+    const keyPair = await crypto.subtle.generateKey(
+      {
+        name: 'ECDH',
+        namedCurve: 'P-256',
+      },
+      true,
+      ['deriveKey', 'deriveBits']
+    );
+    return keyPair;
+  }
+
+  async encrypt(publicKeyHex: string, message: string): Promise<string> {
+    // Generate ephemeral key pair for this encryption
+    const ephemeralKeyPair = await this.generateKeyPair();
+    
+    // Import the provided public key
+    const publicKeyData = hexToUint8Array(publicKeyHex);
+    const importedPublicKey = await crypto.subtle.importKey(
+      'raw',
+      publicKeyData,
+      { name: 'ECDH', namedCurve: 'P-256' },
+      false,
+      []
+    );
+    
+    // Derive shared secret using ephemeral private key and provided public key
+    const sharedKey = await crypto.subtle.deriveKey(
+      { name: 'ECDH', public: importedPublicKey },
+      ephemeralKeyPair.privateKey,
+      { name: 'AES-GCM', length: 256 },
+      false,
+      ['encrypt']
+    );
+    
+    // Generate IV
+    const iv = crypto.getRandomValues(new Uint8Array(12));
+    
+    // Encrypt the message
+    const encoder = new TextEncoder();
+    const data = encoder.encode(message);
+    const encrypted = await crypto.subtle.encrypt(
+      { name: 'AES-GCM', iv },
+      sharedKey,
+      data
+    );
+    
+    // Export ephemeral public key for sender
+    const ephemeralPublicKeyData = await crypto.subtle.exportKey('raw', ephemeralKeyPair.publicKey);
+    
+    return JSON.stringify({
+      encrypted: Array.from(new Uint8Array(encrypted)),
+      iv: Array.from(iv),
+      ephemeralPublicKey: Array.from(new Uint8Array(ephemeralPublicKeyData)),
+      publicKey: publicKeyHex
+    });
+  }
+
+  async decrypt(privateKeyHex: string, encryptedData: string): Promise<string> {
+    try {
+      const data = JSON.parse(encryptedData);
+      
+      // Validate that we have the expected data structure
+      if (!data.encrypted || !data.iv || !data.ephemeralPublicKey) {
+        throw new Error('Invalid encrypted data format');
+      }
+      
+      // Import the private key
+      const privateKeyData = hexToUint8Array(privateKeyHex);
+      const importedPrivateKey = await crypto.subtle.importKey(
+        'pkcs8',
+        privateKeyData,
+        { name: 'ECDH', namedCurve: 'P-256' },
+        false,
+        ['deriveKey']
+      );
+      
+      // Import ephemeral public key
+      const ephemeralPublicKey = await crypto.subtle.importKey(
+        'raw',
+        new Uint8Array(data.ephemeralPublicKey),
+        { name: 'ECDH', namedCurve: 'P-256' },
+        false,
+        []
+      );
+      
+      // Derive the same shared secret
+      const sharedKey = await crypto.subtle.deriveKey(
+        { name: 'ECDH', public: ephemeralPublicKey },
+        importedPrivateKey,
+        { name: 'AES-GCM', length: 256 },
+        false,
+        ['decrypt']
+      );
+      
+      // Decrypt
+      const decrypted = await crypto.subtle.decrypt(
+        { name: 'AES-GCM', iv: new Uint8Array(data.iv) },
+        sharedKey,
+        new Uint8Array(data.encrypted)
+      );
+      
+      return new TextDecoder().decode(decrypted);
+    } catch (error) {
+      throw new Error(`Decryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
+    }
+  }
+}
+
+// Utility functions for browser crypto
+function hexToUint8Array(hex: string): Uint8Array {
+  const result = new Uint8Array(hex.length / 2);
+  for (let i = 0; i < hex.length; i += 2) {
+    result[i / 2] = parseInt(hex.substr(i, 2), 16);
+  }
+  return result;
+}
+
+function uint8ArrayToHex(array: Uint8Array): string {
+  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
+}
+
+// Utility functions for browser crypto remain available if needed in future
+
 /**
  * Browser implementation of crypto operations using eccrypto-js
  */
 class BrowserCryptoAdapter implements VanaCryptoAdapter {
   async encryptWithPublicKey(
     data: string,
-    _publicKey: string,
+    publicKeyHex: string,
   ): Promise<string> {
-    console.warn(
-      "BrowserCryptoAdapter: Using placeholder encryption - not secure for production",
-    );
-    const encoder = new TextEncoder();
-    const dataArray = encoder.encode(data);
-    return `browser-encrypted:${btoa(String.fromCharCode(...dataArray))}:${_publicKey.substring(0, 8)}`;
+    try {
+      const ecdh = new BrowserECDH();
+      return await ecdh.encrypt(publicKeyHex, data);
+    } catch (error) {
+      throw new Error(`Encryption failed: ${error}`);
+    }
   }
 
   async decryptWithPrivateKey(
     encryptedData: string,
-    _privateKey: string,
+    privateKeyHex: string,
   ): Promise<string> {
-    console.warn(
-      "BrowserCryptoAdapter: Using placeholder decryption - not secure for production",
-    );
-    if (encryptedData.startsWith("browser-encrypted:")) {
-      const [, encodedData] = encryptedData.split(":");
-      const decodedData = atob(encodedData);
-      return Array.from(decodedData, (char) => char.charCodeAt(0))
-        .map((byte) => String.fromCharCode(byte))
-        .join("");
+    try {
+      const ecdh = new BrowserECDH();
+      return await ecdh.decrypt(privateKeyHex, encryptedData);
+    } catch (error) {
+      throw new Error(`Decryption failed: ${error}`);
     }
-    return encryptedData;
   }
 
   async generateKeyPair(): Promise<{ publicKey: string; privateKey: string }> {
-    console.warn(
-      "BrowserCryptoAdapter: Using placeholder key generation - not secure for production",
-    );
-    const privateKey = Array.from({ length: 32 }, () =>
-      Math.floor(Math.random() * 256),
-    )
-      .map((b) => b.toString(16).padStart(2, "0"))
-      .join("");
-    const publicKey = Array.from({ length: 33 }, () =>
-      Math.floor(Math.random() * 256),
-    )
-      .map((b) => b.toString(16).padStart(2, "0"))
-      .join("");
-    return { publicKey, privateKey };
+    try {
+      // Generate a secp256k1 compatible key pair using Web Crypto API
+      const keyPair = await crypto.subtle.generateKey(
+        {
+          name: 'ECDH',
+          namedCurve: 'P-256',
+        },
+        true,
+        ['deriveKey', 'deriveBits']
+      );
+      
+      // Export keys as hex strings
+      const publicKeyBuffer = await crypto.subtle.exportKey('raw', keyPair.publicKey);
+      const privateKeyBuffer = await crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
+      
+      return {
+        publicKey: uint8ArrayToHex(new Uint8Array(publicKeyBuffer)),
+        privateKey: uint8ArrayToHex(new Uint8Array(privateKeyBuffer))
+      };
+    } catch (error) {
+      throw new Error(`Key generation failed: ${error}`);
+    }
   }
 }
 
@@ -67,43 +197,66 @@ class BrowserCryptoAdapter implements VanaCryptoAdapter {
  * Browser implementation of PGP operations using openpgp with browser-specific configuration
  */
 class BrowserPGPAdapter implements VanaPGPAdapter {
-  async encrypt(data: string, _publicKey: string): Promise<string> {
-    console.warn(
-      "BrowserPGPAdapter: Using placeholder PGP encryption - not secure for production",
-    );
-    const encoder = new TextEncoder();
-    const encodedData = encoder.encode(data);
-    return `-----BEGIN PGP MESSAGE-----\nbrowser-pgp-encrypted:${btoa(String.fromCharCode(...encodedData))}\n-----END PGP MESSAGE-----`;
+  async encrypt(data: string, publicKeyArmored: string): Promise<string> {
+    try {
+      const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });
+      
+      const encrypted = await openpgp.encrypt({
+        message: await openpgp.createMessage({ text: data }),
+        encryptionKeys: publicKey,
+        config: { preferredCompressionAlgorithm: openpgp.enums.compression.zlib }
+      });
+      
+      return encrypted as string;
+    } catch (error) {
+      throw new Error(`PGP encryption failed: ${error}`);
+    }
   }
 
-  async decrypt(encryptedData: string, _privateKey: string): Promise<string> {
-    console.warn(
-      "BrowserPGPAdapter: Using placeholder PGP decryption - not secure for production",
-    );
-    const match = encryptedData.match(
-      /browser-pgp-encrypted:([A-Za-z0-9+/=]+)/,
-    );
-    if (match) {
-      const decodedData = atob(match[1]);
-      const dataArray = Array.from(decodedData, (char) => char.charCodeAt(0));
-      return new TextDecoder().decode(new Uint8Array(dataArray));
+  async decrypt(encryptedData: string, privateKeyArmored: string): Promise<string> {
+    try {
+      const privateKey = await openpgp.readPrivateKey({ armoredKey: privateKeyArmored });
+      const message = await openpgp.readMessage({ armoredMessage: encryptedData });
+      
+      const { data: decrypted } = await openpgp.decrypt({
+        message,
+        decryptionKeys: privateKey
+      });
+      
+      return decrypted as string;
+    } catch (error) {
+      throw new Error(`PGP decryption failed: ${error}`);
     }
-    return encryptedData;
   }
 
-  async generateKeyPair(_options?: {
+  async generateKeyPair(options?: {
     name?: string;
     email?: string;
     passphrase?: string;
   }): Promise<{ publicKey: string; privateKey: string }> {
-    console.warn(
-      "BrowserPGPAdapter: Using placeholder PGP key generation - not secure for production",
-    );
-
-    return {
-      publicKey: `-----BEGIN PGP PUBLIC KEY BLOCK-----\nbrowser-placeholder-public-key-${Date.now()}\n-----END PGP PUBLIC KEY BLOCK-----`,
-      privateKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\nbrowser-placeholder-private-key-${Date.now()}\n-----END PGP PRIVATE KEY BLOCK-----`,
-    };
+    try {
+      const name = options?.name || 'Vana User';
+      const email = options?.email || 'user@vana.org';
+      const passphrase = options?.passphrase;
+      
+      const { privateKey, publicKey } = await openpgp.generateKey({
+        type: 'rsa',
+        rsaBits: 2048,
+        userIDs: [{ name, email }],
+        passphrase,
+        config: {
+          preferredCompressionAlgorithm: openpgp.enums.compression.zlib,
+          preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256
+        }
+      });
+      
+      return {
+        publicKey,
+        privateKey
+      };
+    } catch (error) {
+      throw new Error(`PGP key generation failed: ${error}`);
+    }
   }
 }
 
@@ -123,9 +276,20 @@ class BrowserHttpAdapter implements VanaHttpAdapter {
 /**
  * Complete browser platform adapter implementation
  */
-export const browserPlatformAdapter: VanaPlatformAdapter = {
-  crypto: new BrowserCryptoAdapter(),
-  pgp: new BrowserPGPAdapter(),
-  http: new BrowserHttpAdapter(),
-  platform: "browser" as const,
-};
+export class BrowserPlatformAdapter implements VanaPlatformAdapter {
+  crypto: VanaCryptoAdapter;
+  pgp: VanaPGPAdapter;
+  http: VanaHttpAdapter;
+  platform: "browser" = "browser" as const;
+
+  constructor() {
+    this.crypto = new BrowserCryptoAdapter();
+    this.pgp = new BrowserPGPAdapter();
+    this.http = new BrowserHttpAdapter();
+  }
+}
+
+/**
+ * Default instance export for backwards compatibility
+ */
+export const browserPlatformAdapter: VanaPlatformAdapter = new BrowserPlatformAdapter();
diff --git a/packages/vana-sdk/src/platform/index.ts b/packages/vana-sdk/src/platform/index.ts
index 33bb872..5211352 100644
--- a/packages/vana-sdk/src/platform/index.ts
+++ b/packages/vana-sdk/src/platform/index.ts
@@ -1,44 +1,20 @@
 /**
- * Platform adapter selection and exports
- *
- * This module provides the appropriate platform adapter based on the current environment.
- * The actual adapter used will be determined by the conditional exports in package.json.
+ * Platform adapter types and implementations
+ * 
+ * This module exports the platform-specific adapters and interfaces
+ * without the getPlatformAdapter function, which has been removed
+ * in favor of explicit adapter injection.
  */
 
+// Export types
 export type {
-  VanaPlatformAdapter,
   VanaCryptoAdapter,
   VanaPGPAdapter,
   VanaHttpAdapter,
+  VanaPlatformAdapter,
+  PlatformType,
 } from "./interface";
 
-// Import the adapters for local use
-import { nodePlatformAdapter } from "./node";
-import { browserPlatformAdapter } from "./browser";
-
-// These will be conditionally exported based on the environment
-export { nodePlatformAdapter } from "./node";
-export { browserPlatformAdapter } from "./browser";
-
-/**
- * Get the platform adapter for the current environment
- * This function will be overridden by conditional exports to return the appropriate adapter
- */
-export function getPlatformAdapter(): import("./interface").VanaPlatformAdapter {
-  // This is a fallback that should never be reached in production
-  // due to conditional exports, but provides a safety net
-
-  // Check if we're in a browser environment
-  const hasWindow =
-    typeof globalThis !== "undefined" &&
-    "window" in globalThis &&
-    typeof (globalThis as Record<string, unknown>).window !== "undefined";
-
-  if (hasWindow) {
-    // Browser environment
-    return browserPlatformAdapter;
-  } else {
-    // Node.js environment
-    return nodePlatformAdapter;
-  }
-}
+// Export implementations
+export { NodePlatformAdapter } from "./node";
+export { BrowserPlatformAdapter } from "./browser";
\ No newline at end of file
diff --git a/packages/vana-sdk/src/platform/interface.ts b/packages/vana-sdk/src/platform/interface.ts
index 5a56463..8fb41e8 100644
--- a/packages/vana-sdk/src/platform/interface.ts
+++ b/packages/vana-sdk/src/platform/interface.ts
@@ -5,6 +5,11 @@
  * the SDK works seamlessly across Node.js and browser/SSR environments.
  */
 
+/**
+ * Platform type identifier
+ */
+export type PlatformType = "node" | "browser";
+
 /**
  * Encryption operations that require different implementations per platform
  */
@@ -102,5 +107,5 @@ export interface VanaPlatformAdapter {
   /**
    * Platform identifier for debugging/telemetry
    */
-  readonly platform: "node" | "browser";
+  readonly platform: PlatformType;
 }
diff --git a/packages/vana-sdk/src/platform/node.ts b/packages/vana-sdk/src/platform/node.ts
index d5692f6..fe0be1c 100644
--- a/packages/vana-sdk/src/platform/node.ts
+++ b/packages/vana-sdk/src/platform/node.ts
@@ -5,6 +5,8 @@
  * to provide crypto, PGP, and HTTP functionality.
  */
 
+import { randomBytes } from "crypto";
+import * as openpgp from "openpgp";
 import {
   VanaPlatformAdapter,
   VanaCryptoAdapter,
@@ -12,45 +14,110 @@ import {
   VanaHttpAdapter,
 } from "./interface";
 
+// Eccrypto type definitions removed - using dynamic imports instead
+
+// Dynamically import eccrypto for Node.js
+let eccrypto: {
+  encrypt: (publicKey: Buffer, message: Buffer) => Promise<{
+    iv: Buffer;
+    ephemPublicKey: Buffer;
+    ciphertext: Buffer;
+    mac: Buffer;
+  }>;
+  decrypt: (privateKey: Buffer, encrypted: {
+    iv: Buffer;
+    ephemPublicKey: Buffer;
+    ciphertext: Buffer;
+    mac: Buffer;
+  }) => Promise<Buffer>;
+  getPublicCompressed: (privateKey: Buffer) => Buffer;
+} | null = null;
+
+// Lazy load eccrypto
+async function getEccrypto() {
+  if (!eccrypto) {
+    try {
+      // Import the eccrypto library for Node.js
+      const eccryptoLib = await import("eccrypto");
+      
+      eccrypto = {
+        encrypt: eccryptoLib.encrypt,
+        decrypt: eccryptoLib.decrypt,
+        getPublicCompressed: eccryptoLib.getPublicCompressed
+      };
+    } catch (error) {
+      throw new Error(`Failed to load eccrypto library: ${error}`);
+    }
+  }
+  return eccrypto;
+}
+
 /**
- * Node.js implementation of crypto operations using eccrypto
+ * Node.js implementation of crypto operations using secp256k1
  */
 class NodeCryptoAdapter implements VanaCryptoAdapter {
   async encryptWithPublicKey(
     data: string,
-    _publicKey: string,
+    publicKeyHex: string,
   ): Promise<string> {
-    console.warn(
-      "NodeCryptoAdapter: Using placeholder encryption - not secure for production",
-    );
-    return `node-encrypted:${Buffer.from(data).toString("base64")}:${_publicKey.substring(0, 8)}`;
+    try {
+      const eccryptoLib = await getEccrypto();
+      const publicKey = Buffer.from(publicKeyHex, 'hex');
+      const message = Buffer.from(data, 'utf8');
+      
+      const encrypted = await eccryptoLib.encrypt(publicKey, message);
+      
+      // Serialize encrypted data as JSON
+      const serialized = {
+        iv: encrypted.iv.toString('hex'),
+        ephemPublicKey: encrypted.ephemPublicKey.toString('hex'),
+        ciphertext: encrypted.ciphertext.toString('hex'),
+        mac: encrypted.mac.toString('hex')
+      };
+      
+      return JSON.stringify(serialized);
+    } catch (error) {
+      throw new Error(`Encryption failed: ${error}`);
+    }
   }
 
   async decryptWithPrivateKey(
     encryptedData: string,
-    _privateKey: string,
+    privateKeyHex: string,
   ): Promise<string> {
-    console.warn(
-      "NodeCryptoAdapter: Using placeholder decryption - not secure for production",
-    );
-    if (encryptedData.startsWith("node-encrypted:")) {
-      const [, encodedData] = encryptedData.split(":");
-      return Buffer.from(encodedData, "base64").toString("utf8");
+    try {
+      const eccryptoLib = await getEccrypto();
+      const privateKey = Buffer.from(privateKeyHex, 'hex');
+      
+      // Deserialize encrypted data
+      const serialized = JSON.parse(encryptedData);
+      const encrypted = {
+        iv: Buffer.from(serialized.iv, 'hex'),
+        ephemPublicKey: Buffer.from(serialized.ephemPublicKey, 'hex'),
+        ciphertext: Buffer.from(serialized.ciphertext, 'hex'),
+        mac: Buffer.from(serialized.mac, 'hex')
+      };
+      
+      const decrypted = await eccryptoLib.decrypt(privateKey, encrypted);
+      return decrypted.toString('utf8');
+    } catch (error) {
+      throw new Error(`Decryption failed: ${error}`);
     }
-    return encryptedData;
   }
 
   async generateKeyPair(): Promise<{ publicKey: string; privateKey: string }> {
-    console.warn(
-      "NodeCryptoAdapter: Using placeholder key generation - not secure for production",
-    );
-    const privateKey = Buffer.from(
-      Array.from({ length: 32 }, () => Math.floor(Math.random() * 256)),
-    ).toString("hex");
-    const publicKey = Buffer.from(
-      Array.from({ length: 33 }, () => Math.floor(Math.random() * 256)),
-    ).toString("hex");
-    return { publicKey, privateKey };
+    try {
+      const eccryptoLib = await getEccrypto();
+      const privateKey = randomBytes(32);
+      const publicKey = eccryptoLib.getPublicCompressed(privateKey);
+      
+      return {
+        privateKey: privateKey.toString('hex'),
+        publicKey: publicKey.toString('hex')
+      };
+    } catch (error) {
+      throw new Error(`Key generation failed: ${error}`);
+    }
   }
 }
 
@@ -58,37 +125,66 @@ class NodeCryptoAdapter implements VanaCryptoAdapter {
  * Node.js implementation of PGP operations using openpgp with Node-specific configuration
  */
 class NodePGPAdapter implements VanaPGPAdapter {
-  async encrypt(data: string, _publicKey: string): Promise<string> {
-    console.warn(
-      "NodePGPAdapter: Using placeholder PGP encryption - not secure for production",
-    );
-    return `-----BEGIN PGP MESSAGE-----\nnode-pgp-encrypted:${Buffer.from(data).toString("base64")}\n-----END PGP MESSAGE-----`;
+  async encrypt(data: string, publicKeyArmored: string): Promise<string> {
+    try {
+      const publicKey = await openpgp.readKey({ armoredKey: publicKeyArmored });
+      
+      const encrypted = await openpgp.encrypt({
+        message: await openpgp.createMessage({ text: data }),
+        encryptionKeys: publicKey,
+        config: { preferredCompressionAlgorithm: openpgp.enums.compression.zlib }
+      });
+      
+      return encrypted as string;
+    } catch (error) {
+      throw new Error(`PGP encryption failed: ${error}`);
+    }
   }
 
-  async decrypt(encryptedData: string, _privateKey: string): Promise<string> {
-    console.warn(
-      "NodePGPAdapter: Using placeholder PGP decryption - not secure for production",
-    );
-    const match = encryptedData.match(/node-pgp-encrypted:([A-Za-z0-9+/=]+)/);
-    if (match) {
-      return Buffer.from(match[1], "base64").toString("utf8");
+  async decrypt(encryptedData: string, privateKeyArmored: string): Promise<string> {
+    try {
+      const privateKey = await openpgp.readPrivateKey({ armoredKey: privateKeyArmored });
+      const message = await openpgp.readMessage({ armoredMessage: encryptedData });
+      
+      const { data: decrypted } = await openpgp.decrypt({
+        message,
+        decryptionKeys: privateKey
+      });
+      
+      return decrypted as string;
+    } catch (error) {
+      throw new Error(`PGP decryption failed: ${error}`);
     }
-    return encryptedData;
   }
 
-  async generateKeyPair(_options?: {
+  async generateKeyPair(options?: {
     name?: string;
     email?: string;
     passphrase?: string;
   }): Promise<{ publicKey: string; privateKey: string }> {
-    console.warn(
-      "NodePGPAdapter: Using placeholder PGP key generation - not secure for production",
-    );
-
-    return {
-      publicKey: `-----BEGIN PGP PUBLIC KEY BLOCK-----\nnode-placeholder-public-key-${Date.now()}\n-----END PGP PUBLIC KEY BLOCK-----`,
-      privateKey: `-----BEGIN PGP PRIVATE KEY BLOCK-----\nnode-placeholder-private-key-${Date.now()}\n-----END PGP PRIVATE KEY BLOCK-----`,
-    };
+    try {
+      const name = options?.name || 'Vana User';
+      const email = options?.email || 'user@vana.org';
+      const passphrase = options?.passphrase;
+      
+      const { privateKey, publicKey } = await openpgp.generateKey({
+        type: 'rsa',
+        rsaBits: 2048,
+        userIDs: [{ name, email }],
+        passphrase,
+        config: {
+          preferredCompressionAlgorithm: openpgp.enums.compression.zlib,
+          preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256
+        }
+      });
+      
+      return {
+        publicKey,
+        privateKey
+      };
+    } catch (error) {
+      throw new Error(`PGP key generation failed: ${error}`);
+    }
   }
 }
 
@@ -108,9 +204,20 @@ class NodeHttpAdapter implements VanaHttpAdapter {
 /**
  * Complete Node.js platform adapter implementation
  */
-export const nodePlatformAdapter: VanaPlatformAdapter = {
-  crypto: new NodeCryptoAdapter(),
-  pgp: new NodePGPAdapter(),
-  http: new NodeHttpAdapter(),
-  platform: "node" as const,
-};
+export class NodePlatformAdapter implements VanaPlatformAdapter {
+  crypto: VanaCryptoAdapter;
+  pgp: VanaPGPAdapter;
+  http: VanaHttpAdapter;
+  platform: "node" = "node" as const;
+
+  constructor() {
+    this.crypto = new NodeCryptoAdapter();
+    this.pgp = new NodePGPAdapter();
+    this.http = new NodeHttpAdapter();
+  }
+}
+
+/**
+ * Default instance export for backwards compatibility
+ */
+export const nodePlatformAdapter: VanaPlatformAdapter = new NodePlatformAdapter();
diff --git a/packages/vana-sdk/src/tests/data-relayer.test.ts b/packages/vana-sdk/src/tests/data-relayer.test.ts
index ad15326..9d5e38f 100644
--- a/packages/vana-sdk/src/tests/data-relayer.test.ts
+++ b/packages/vana-sdk/src/tests/data-relayer.test.ts
@@ -2,6 +2,7 @@ import { describe, it, expect, vi, beforeEach } from "vitest";
 import { DataController } from "../controllers/data";
 import { ControllerContext } from "../controllers/permissions";
 import { Address } from "viem";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock global fetch
 const mockFetch = vi.fn();
@@ -56,6 +57,7 @@ describe("DataController Relayer Integration", () => {
       },
       storageManager:
         mockStorageManager as unknown as ControllerContext["storageManager"],
+      platform: mockPlatformAdapter,
     };
 
     dataController = new DataController(mockContext);
diff --git a/packages/vana-sdk/src/tests/data.test.ts b/packages/vana-sdk/src/tests/data.test.ts
index 25d0187..c72781a 100644
--- a/packages/vana-sdk/src/tests/data.test.ts
+++ b/packages/vana-sdk/src/tests/data.test.ts
@@ -10,6 +10,7 @@ import type {
   StorageFile as _StorageFile,
   StorageListOptions as _StorageListOptions,
 } from "../storage/index";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock ALL external dependencies for pure unit tests
 vi.mock("../utils/encryption", () => ({
@@ -166,6 +167,7 @@ describe("DataController", () => {
         mockPublicClient as unknown as ControllerContext["publicClient"],
       subgraphUrl:
         "https://api.goldsky.com/api/public/project_cm168cz887zva010j39il7a6p/subgraphs/moksha/7.0.1/gn",
+      platform: mockPlatformAdapter,
     };
 
     controller = new DataController(mockContext);
diff --git a/packages/vana-sdk/src/tests/new-permissions-methods.test.ts b/packages/vana-sdk/src/tests/new-permissions-methods.test.ts
index 99fa613..727790e 100644
--- a/packages/vana-sdk/src/tests/new-permissions-methods.test.ts
+++ b/packages/vana-sdk/src/tests/new-permissions-methods.test.ts
@@ -4,6 +4,7 @@ import {
   PermissionsController,
   ControllerContext,
 } from "../controllers/permissions";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock ALL external dependencies to ensure pure unit tests
 vi.mock("viem", () => ({
@@ -65,6 +66,7 @@ describe("New PermissionsController Methods", () => {
         mockWalletClient as unknown as ControllerContext["walletClient"],
       publicClient:
         mockPublicClient as unknown as ControllerContext["publicClient"],
+      platform: mockPlatformAdapter,
     };
 
     controller = new PermissionsController(mockContext);
diff --git a/packages/vana-sdk/src/tests/permissions.test.ts b/packages/vana-sdk/src/tests/permissions.test.ts
index bc3daea..f8c0df3 100644
--- a/packages/vana-sdk/src/tests/permissions.test.ts
+++ b/packages/vana-sdk/src/tests/permissions.test.ts
@@ -13,6 +13,7 @@ import {
   SignatureError,
   PermissionError,
 } from "../errors";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock ALL external dependencies to ensure pure unit tests
 vi.mock("viem", () => ({
@@ -157,6 +158,7 @@ describe("PermissionsController", () => {
         storeGrantFile: vi.fn().mockResolvedValue("https://mock-grant-url.com"),
         submitPermissionGrant: vi.fn().mockResolvedValue("0xtxhash"),
       },
+      platform: mockPlatformAdapter,
     };
 
     controller = new PermissionsController(mockContext);
@@ -344,6 +346,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         // No relayerUrl - forces direct transaction path
       });
     });
@@ -690,6 +693,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitPermissionGrant: vi.fn().mockResolvedValue("0xtxhash"),
           submitPermissionRevoke: vi.fn().mockResolvedValue("0xtxhash"),
@@ -784,6 +788,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitPermissionGrant: vi
             .fn()
@@ -819,6 +824,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitPermissionGrant: vi
             .fn()
@@ -853,6 +859,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         // No relayerUrl - forces direct transaction path
       });
 
@@ -894,6 +901,7 @@ describe("PermissionsController", () => {
           noChainWallet as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         // No relayerUrl - forces direct transaction path
       });
 
@@ -921,6 +929,7 @@ describe("PermissionsController", () => {
           noAccountWallet as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         // No relayerUrl - forces direct transaction path
       });
 
@@ -961,6 +970,7 @@ describe("PermissionsController", () => {
           noChainWallet as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitPermissionGrant: vi.fn().mockResolvedValue("0xtxhash"),
           submitPermissionRevoke: vi.fn().mockResolvedValue("0xtxhash"),
@@ -983,6 +993,7 @@ describe("PermissionsController", () => {
           mockWalletClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitPermissionGrant: vi
             .fn()
diff --git a/packages/vana-sdk/src/tests/personal.test.ts b/packages/vana-sdk/src/tests/personal.test.ts
index 0bfb59c..1839cc5 100644
--- a/packages/vana-sdk/src/tests/personal.test.ts
+++ b/packages/vana-sdk/src/tests/personal.test.ts
@@ -4,6 +4,7 @@ import { ServerController } from "../controllers/server";
 import { ControllerContext } from "../controllers/permissions";
 import { NetworkError, SignatureError, PersonalServerError } from "../errors";
 import { PostRequestParams, InitPersonalServerParams } from "../types";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock global fetch
 const mockFetch = vi.fn();
@@ -70,6 +71,7 @@ describe("ServerController", () => {
       applicationClient:
         mockApplicationClient as unknown as ControllerContext["applicationClient"],
       publicClient: {} as unknown as ControllerContext["publicClient"],
+      platform: mockPlatformAdapter,
     };
 
     serverController = new ServerController(mockContext);
diff --git a/packages/vana-sdk/src/tests/platform.test.ts b/packages/vana-sdk/src/tests/platform.test.ts
deleted file mode 100644
index 59cb931..0000000
--- a/packages/vana-sdk/src/tests/platform.test.ts
+++ /dev/null
@@ -1,501 +0,0 @@
-import { describe, it, expect, vi, afterEach } from "vitest";
-import { browserPlatformAdapter } from "../platform/browser";
-import { nodePlatformAdapter } from "../platform/node";
-
-// Store original fetch for restoration
-const originalFetch = globalThis.fetch;
-
-describe("Platform Adapters", () => {
-  afterEach(() => {
-    // Restore original fetch
-    globalThis.fetch = originalFetch;
-    vi.clearAllMocks();
-  });
-
-  describe("Browser Platform Adapter", () => {
-    describe("BrowserCryptoAdapter", () => {
-      it("should encrypt data with public key", async () => {
-        const data = "test data";
-        const publicKey = "public-key-123";
-
-        const result = await browserPlatformAdapter.crypto.encryptWithPublicKey(
-          data,
-          publicKey,
-        );
-
-        expect(result).toContain("browser-encrypted:");
-        expect(result).toContain(btoa("test data"));
-        expect(result).toContain(publicKey.substring(0, 8));
-      });
-
-      it("should decrypt data with private key", async () => {
-        const data = "test data";
-        const publicKey = "public-key-123";
-        const privateKey = "private-key-456";
-
-        // First encrypt
-        const encrypted =
-          await browserPlatformAdapter.crypto.encryptWithPublicKey(
-            data,
-            publicKey,
-          );
-
-        // Then decrypt
-        const decrypted =
-          await browserPlatformAdapter.crypto.decryptWithPrivateKey(
-            encrypted,
-            privateKey,
-          );
-
-        expect(decrypted).toBe(data);
-      });
-
-      it("should handle non-encrypted data in decryption", async () => {
-        const plainData = "plain data";
-        const privateKey = "private-key-456";
-
-        const result =
-          await browserPlatformAdapter.crypto.decryptWithPrivateKey(
-            plainData,
-            privateKey,
-          );
-
-        expect(result).toBe(plainData);
-      });
-
-      it("should generate key pair", async () => {
-        const keyPair = await browserPlatformAdapter.crypto.generateKeyPair();
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(typeof keyPair.publicKey).toBe("string");
-        expect(typeof keyPair.privateKey).toBe("string");
-        expect(keyPair.publicKey.length).toBe(66); // 33 bytes * 2 hex chars
-        expect(keyPair.privateKey.length).toBe(64); // 32 bytes * 2 hex chars
-      });
-
-      it("should generate different key pairs on subsequent calls", async () => {
-        const keyPair1 = await browserPlatformAdapter.crypto.generateKeyPair();
-        const keyPair2 = await browserPlatformAdapter.crypto.generateKeyPair();
-
-        expect(keyPair1.publicKey).not.toBe(keyPair2.publicKey);
-        expect(keyPair1.privateKey).not.toBe(keyPair2.privateKey);
-      });
-    });
-
-    describe("BrowserPGPAdapter", () => {
-      it("should encrypt data with PGP", async () => {
-        const data = "sensitive data";
-        const publicKey = "pgp-public-key";
-
-        const result = await browserPlatformAdapter.pgp.encrypt(
-          data,
-          publicKey,
-        );
-
-        expect(result).toContain("-----BEGIN PGP MESSAGE-----");
-        expect(result).toContain("-----END PGP MESSAGE-----");
-        expect(result).toContain("browser-pgp-encrypted:");
-        expect(result).toContain(btoa(data));
-      });
-
-      it("should decrypt PGP data", async () => {
-        const data = "sensitive data";
-        const publicKey = "pgp-public-key";
-        const privateKey = "pgp-private-key";
-
-        // First encrypt
-        const encrypted = await browserPlatformAdapter.pgp.encrypt(
-          data,
-          publicKey,
-        );
-
-        // Then decrypt
-        const decrypted = await browserPlatformAdapter.pgp.decrypt(
-          encrypted,
-          privateKey,
-        );
-
-        expect(decrypted).toBe(data);
-      });
-
-      it("should handle non-PGP data in decryption", async () => {
-        const plainData = "plain data";
-        const privateKey = "pgp-private-key";
-
-        const result = await browserPlatformAdapter.pgp.decrypt(
-          plainData,
-          privateKey,
-        );
-
-        expect(result).toBe(plainData);
-      });
-
-      it("should generate PGP key pair without options", async () => {
-        const keyPair = await browserPlatformAdapter.pgp.generateKeyPair();
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(keyPair.publicKey).toContain(
-          "-----BEGIN PGP PUBLIC KEY BLOCK-----",
-        );
-        expect(keyPair.publicKey).toContain(
-          "-----END PGP PUBLIC KEY BLOCK-----",
-        );
-        expect(keyPair.privateKey).toContain(
-          "-----BEGIN PGP PRIVATE KEY BLOCK-----",
-        );
-        expect(keyPair.privateKey).toContain(
-          "-----END PGP PRIVATE KEY BLOCK-----",
-        );
-      });
-
-      it("should generate PGP key pair with options", async () => {
-        const options = {
-          name: "Test User",
-          email: "test@example.com",
-          passphrase: "secure-passphrase",
-        };
-
-        const keyPair =
-          await browserPlatformAdapter.pgp.generateKeyPair(options);
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(keyPair.publicKey).toContain("browser-placeholder-public-key");
-        expect(keyPair.privateKey).toContain("browser-placeholder-private-key");
-      });
-
-      it("should generate different PGP key pairs on subsequent calls", async () => {
-        const keyPair1 = await browserPlatformAdapter.pgp.generateKeyPair();
-        // Wait a millisecond to ensure different timestamp
-        await new Promise((resolve) => setTimeout(resolve, 2));
-        const keyPair2 = await browserPlatformAdapter.pgp.generateKeyPair();
-
-        expect(keyPair1.publicKey).not.toBe(keyPair2.publicKey);
-        expect(keyPair1.privateKey).not.toBe(keyPair2.privateKey);
-      });
-    });
-
-    describe("BrowserHttpAdapter", () => {
-      it("should make HTTP request using fetch", async () => {
-        const mockResponse = new Response("test response", { status: 200 });
-        globalThis.fetch = vi.fn().mockResolvedValue(mockResponse);
-
-        const result = await browserPlatformAdapter.http.fetch(
-          "https://example.com",
-        );
-
-        expect(result).toBe(mockResponse);
-        expect(globalThis.fetch).toHaveBeenCalledWith(
-          "https://example.com",
-          undefined,
-        );
-      });
-
-      it("should pass options to fetch", async () => {
-        const mockResponse = new Response("test response", { status: 200 });
-        globalThis.fetch = vi.fn().mockResolvedValue(mockResponse);
-
-        const options = {
-          method: "POST",
-          headers: { "Content-Type": "application/json" },
-          body: JSON.stringify({ test: "data" }),
-        };
-
-        const result = await browserPlatformAdapter.http.fetch(
-          "https://example.com/api",
-          options,
-        );
-
-        expect(result).toBe(mockResponse);
-        expect(globalThis.fetch).toHaveBeenCalledWith(
-          "https://example.com/api",
-          options,
-        );
-      });
-
-      it("should throw error when fetch is not available", async () => {
-        // Remove fetch from global
-        globalThis.fetch = undefined as unknown as typeof fetch;
-
-        await expect(
-          browserPlatformAdapter.http.fetch("https://example.com"),
-        ).rejects.toThrow(
-          "Fetch API not available in this browser environment",
-        );
-      });
-    });
-
-    describe("Platform Integration", () => {
-      it("should have correct platform identifier", () => {
-        expect(browserPlatformAdapter.platform).toBe("browser");
-      });
-
-      it("should provide all required adapters", () => {
-        expect(browserPlatformAdapter.crypto).toBeDefined();
-        expect(browserPlatformAdapter.pgp).toBeDefined();
-        expect(browserPlatformAdapter.http).toBeDefined();
-      });
-    });
-  });
-
-  describe("Node Platform Adapter", () => {
-    describe("NodeCryptoAdapter", () => {
-      it("should encrypt data with public key", async () => {
-        const data = "test data";
-        const publicKey = "public-key-123";
-
-        const result = await nodePlatformAdapter.crypto.encryptWithPublicKey(
-          data,
-          publicKey,
-        );
-
-        expect(result).toContain("node-encrypted:");
-        expect(result).toContain(Buffer.from(data).toString("base64"));
-        expect(result).toContain(publicKey.substring(0, 8));
-      });
-
-      it("should decrypt data with private key", async () => {
-        const data = "test data";
-        const publicKey = "public-key-123";
-        const privateKey = "private-key-456";
-
-        // First encrypt
-        const encrypted = await nodePlatformAdapter.crypto.encryptWithPublicKey(
-          data,
-          publicKey,
-        );
-
-        // Then decrypt
-        const decrypted =
-          await nodePlatformAdapter.crypto.decryptWithPrivateKey(
-            encrypted,
-            privateKey,
-          );
-
-        expect(decrypted).toBe(data);
-      });
-
-      it("should handle non-encrypted data in decryption", async () => {
-        const plainData = "plain data";
-        const privateKey = "private-key-456";
-
-        const result = await nodePlatformAdapter.crypto.decryptWithPrivateKey(
-          plainData,
-          privateKey,
-        );
-
-        expect(result).toBe(plainData);
-      });
-
-      it("should generate key pair", async () => {
-        const keyPair = await nodePlatformAdapter.crypto.generateKeyPair();
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(typeof keyPair.publicKey).toBe("string");
-        expect(typeof keyPair.privateKey).toBe("string");
-        expect(keyPair.publicKey.length).toBe(66); // 33 bytes * 2 hex chars
-        expect(keyPair.privateKey.length).toBe(64); // 32 bytes * 2 hex chars
-      });
-
-      it("should generate different key pairs on subsequent calls", async () => {
-        const keyPair1 = await nodePlatformAdapter.crypto.generateKeyPair();
-        const keyPair2 = await nodePlatformAdapter.crypto.generateKeyPair();
-
-        expect(keyPair1.publicKey).not.toBe(keyPair2.publicKey);
-        expect(keyPair1.privateKey).not.toBe(keyPair2.privateKey);
-      });
-    });
-
-    describe("NodePGPAdapter", () => {
-      it("should encrypt data with PGP", async () => {
-        const data = "sensitive data";
-        const publicKey = "pgp-public-key";
-
-        const result = await nodePlatformAdapter.pgp.encrypt(data, publicKey);
-
-        expect(result).toContain("-----BEGIN PGP MESSAGE-----");
-        expect(result).toContain("-----END PGP MESSAGE-----");
-        expect(result).toContain("node-pgp-encrypted:");
-        expect(result).toContain(Buffer.from(data).toString("base64"));
-      });
-
-      it("should decrypt PGP data", async () => {
-        const data = "sensitive data";
-        const publicKey = "pgp-public-key";
-        const privateKey = "pgp-private-key";
-
-        // First encrypt
-        const encrypted = await nodePlatformAdapter.pgp.encrypt(
-          data,
-          publicKey,
-        );
-
-        // Then decrypt
-        const decrypted = await nodePlatformAdapter.pgp.decrypt(
-          encrypted,
-          privateKey,
-        );
-
-        expect(decrypted).toBe(data);
-      });
-
-      it("should handle non-PGP data in decryption", async () => {
-        const plainData = "plain data";
-        const privateKey = "pgp-private-key";
-
-        const result = await nodePlatformAdapter.pgp.decrypt(
-          plainData,
-          privateKey,
-        );
-
-        expect(result).toBe(plainData);
-      });
-
-      it("should generate PGP key pair without options", async () => {
-        const keyPair = await nodePlatformAdapter.pgp.generateKeyPair();
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(keyPair.publicKey).toContain(
-          "-----BEGIN PGP PUBLIC KEY BLOCK-----",
-        );
-        expect(keyPair.publicKey).toContain(
-          "-----END PGP PUBLIC KEY BLOCK-----",
-        );
-        expect(keyPair.privateKey).toContain(
-          "-----BEGIN PGP PRIVATE KEY BLOCK-----",
-        );
-        expect(keyPair.privateKey).toContain(
-          "-----END PGP PRIVATE KEY BLOCK-----",
-        );
-      });
-
-      it("should generate PGP key pair with options", async () => {
-        const options = {
-          name: "Test User",
-          email: "test@example.com",
-          passphrase: "secure-passphrase",
-        };
-
-        const keyPair = await nodePlatformAdapter.pgp.generateKeyPair(options);
-
-        expect(keyPair).toHaveProperty("publicKey");
-        expect(keyPair).toHaveProperty("privateKey");
-        expect(keyPair.publicKey).toContain("node-placeholder-public-key");
-        expect(keyPair.privateKey).toContain("node-placeholder-private-key");
-      });
-
-      it("should generate different PGP key pairs on subsequent calls", async () => {
-        const keyPair1 = await nodePlatformAdapter.pgp.generateKeyPair();
-        // Wait a millisecond to ensure different timestamp
-        await new Promise((resolve) => setTimeout(resolve, 2));
-        const keyPair2 = await nodePlatformAdapter.pgp.generateKeyPair();
-
-        expect(keyPair1.publicKey).not.toBe(keyPair2.publicKey);
-        expect(keyPair1.privateKey).not.toBe(keyPair2.privateKey);
-      });
-    });
-
-    describe("NodeHttpAdapter", () => {
-      it("should make HTTP request using global fetch", async () => {
-        const mockResponse = new Response("test response", { status: 200 });
-        globalThis.fetch = vi.fn().mockResolvedValue(mockResponse);
-
-        const result = await nodePlatformAdapter.http.fetch(
-          "https://example.com",
-        );
-
-        expect(result).toBe(mockResponse);
-        expect(globalThis.fetch).toHaveBeenCalledWith(
-          "https://example.com",
-          undefined,
-        );
-      });
-
-      it("should pass options to fetch", async () => {
-        const mockResponse = new Response("test response", { status: 200 });
-        globalThis.fetch = vi.fn().mockResolvedValue(mockResponse);
-
-        const options = {
-          method: "POST",
-          headers: { "Content-Type": "application/json" },
-          body: JSON.stringify({ test: "data" }),
-        };
-
-        const result = await nodePlatformAdapter.http.fetch(
-          "https://example.com/api",
-          options,
-        );
-
-        expect(result).toBe(mockResponse);
-        expect(globalThis.fetch).toHaveBeenCalledWith(
-          "https://example.com/api",
-          options,
-        );
-      });
-
-      it("should throw error when fetch is not available", async () => {
-        // Remove fetch from global
-        globalThis.fetch = undefined as unknown as typeof fetch;
-
-        await expect(
-          nodePlatformAdapter.http.fetch("https://example.com"),
-        ).rejects.toThrow(
-          "No fetch implementation available in Node.js environment",
-        );
-      });
-    });
-
-    describe("Platform Integration", () => {
-      it("should have correct platform identifier", () => {
-        expect(nodePlatformAdapter.platform).toBe("node");
-      });
-
-      it("should provide all required adapters", () => {
-        expect(nodePlatformAdapter.crypto).toBeDefined();
-        expect(nodePlatformAdapter.pgp).toBeDefined();
-        expect(nodePlatformAdapter.http).toBeDefined();
-      });
-    });
-  });
-
-  describe("Cross-Platform Compatibility", () => {
-    it("should have consistent crypto interfaces", () => {
-      const browserCrypto = browserPlatformAdapter.crypto;
-      const nodeCrypto = nodePlatformAdapter.crypto;
-
-      // Check that both have the same methods
-      expect(typeof browserCrypto.encryptWithPublicKey).toBe("function");
-      expect(typeof nodeCrypto.encryptWithPublicKey).toBe("function");
-      expect(typeof browserCrypto.decryptWithPrivateKey).toBe("function");
-      expect(typeof nodeCrypto.decryptWithPrivateKey).toBe("function");
-      expect(typeof browserCrypto.generateKeyPair).toBe("function");
-      expect(typeof nodeCrypto.generateKeyPair).toBe("function");
-    });
-
-    it("should have consistent PGP interfaces", () => {
-      const browserPGP = browserPlatformAdapter.pgp;
-      const nodePGP = nodePlatformAdapter.pgp;
-
-      // Check that both have the same methods
-      expect(typeof browserPGP.encrypt).toBe("function");
-      expect(typeof nodePGP.encrypt).toBe("function");
-      expect(typeof browserPGP.decrypt).toBe("function");
-      expect(typeof nodePGP.decrypt).toBe("function");
-      expect(typeof browserPGP.generateKeyPair).toBe("function");
-      expect(typeof nodePGP.generateKeyPair).toBe("function");
-    });
-
-    it("should have consistent HTTP interfaces", () => {
-      const browserHttp = browserPlatformAdapter.http;
-      const nodeHttp = nodePlatformAdapter.http;
-
-      // Check that both have the same methods
-      expect(typeof browserHttp.fetch).toBe("function");
-      expect(typeof nodeHttp.fetch).toBe("function");
-    });
-  });
-});
diff --git a/packages/vana-sdk/src/tests/protocol.test.ts b/packages/vana-sdk/src/tests/protocol.test.ts
index 61c8822..4a9ff47 100644
--- a/packages/vana-sdk/src/tests/protocol.test.ts
+++ b/packages/vana-sdk/src/tests/protocol.test.ts
@@ -5,6 +5,7 @@ import { mokshaTestnet } from "../config/chains";
 import { ProtocolController } from "../controllers/protocol";
 import { ControllerContext } from "../controllers/permissions";
 import { ContractNotFoundError } from "../errors";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock the config and ABI modules
 vi.mock("../config/addresses", () => ({
@@ -85,6 +86,7 @@ describe("ProtocolController", () => {
           transactionHash: "0x123456789abcdef",
         }),
       },
+      platform: mockPlatformAdapter,
     };
 
     controller = new ProtocolController(mockContext);
@@ -135,6 +137,7 @@ describe("ProtocolController", () => {
           noChainClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitFileAddition: vi.fn(),
         },
@@ -264,6 +267,7 @@ describe("ProtocolController", () => {
           noChainClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitFileAddition: vi.fn(),
         },
@@ -292,6 +296,7 @@ describe("ProtocolController", () => {
           noChainClient as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
         relayerCallbacks: {
           submitFileAddition: vi.fn(),
         },
@@ -421,6 +426,7 @@ describe("ProtocolController", () => {
           walletClientWithDynamicId as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
       });
 
       // Mock getContractAddress to throw an error that contains "Contract address not found"
@@ -459,6 +465,7 @@ describe("ProtocolController", () => {
           walletClientWithThrowingId as unknown as ControllerContext["walletClient"],
         publicClient:
           mockPublicClient as unknown as ControllerContext["publicClient"],
+        platform: mockPlatformAdapter,
       });
 
       // Should throw the error from the id getter
diff --git a/packages/vana-sdk/src/tests/utils-encryption-additional.test.ts b/packages/vana-sdk/src/tests/utils-encryption-additional.test.ts
index eb595b2..05ce142 100644
--- a/packages/vana-sdk/src/tests/utils-encryption-additional.test.ts
+++ b/packages/vana-sdk/src/tests/utils-encryption-additional.test.ts
@@ -28,10 +28,7 @@ const mockPlatformAdapter: VanaPlatformAdapter = {
   platform: "node",
 };
 
-// Mock the platform module
-vi.mock("../platform", () => ({
-  getPlatformAdapter: () => mockPlatformAdapter,
-}));
+// No longer need to mock the platform module since we pass platform adapters directly
 
 describe("Additional Encryption Utils", () => {
   beforeEach(() => {
@@ -48,7 +45,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockResolvedValue(expectedEncrypted);
 
-      const result = await encryptWithWalletPublicKey(data, publicKey);
+      const result = await encryptWithWalletPublicKey(data, publicKey, mockPlatformAdapter);
 
       expect(result).toBe(expectedEncrypted);
       expect(
@@ -65,7 +62,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockResolvedValue(expectedEncrypted);
 
-      const result = await encryptWithWalletPublicKey(data, publicKey);
+      const result = await encryptWithWalletPublicKey(data, publicKey, mockPlatformAdapter);
 
       expect(result).toBe(expectedEncrypted);
       expect(
@@ -81,7 +78,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockRejectedValue(new Error("Encryption failed"));
 
-      await expect(encryptWithWalletPublicKey(data, publicKey)).rejects.toThrow(
+      await expect(encryptWithWalletPublicKey(data, publicKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt with wallet public key: Error: Encryption failed",
       );
     });
@@ -94,7 +91,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockRejectedValue("String error");
 
-      await expect(encryptWithWalletPublicKey(data, publicKey)).rejects.toThrow(
+      await expect(encryptWithWalletPublicKey(data, publicKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt with wallet public key: String error",
       );
     });
@@ -113,6 +110,7 @@ describe("Additional Encryption Utils", () => {
       const result = await decryptWithWalletPrivateKey(
         encryptedData,
         privateKey,
+        mockPlatformAdapter,
       );
 
       expect(result).toBe(expectedDecrypted);
@@ -130,7 +128,7 @@ describe("Additional Encryption Utils", () => {
       ).mockRejectedValue(new Error("Decryption failed"));
 
       await expect(
-        decryptWithWalletPrivateKey(encryptedData, privateKey),
+        decryptWithWalletPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with wallet private key: Error: Decryption failed",
       );
@@ -145,7 +143,7 @@ describe("Additional Encryption Utils", () => {
       ).mockRejectedValue("Decryption error");
 
       await expect(
-        decryptWithWalletPrivateKey(encryptedData, privateKey),
+        decryptWithWalletPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with wallet private key: Decryption error",
       );
@@ -162,7 +160,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockResolvedValue(expectedEncrypted);
 
-      const result = await encryptFileKey(fileKey, publicKey);
+      const result = await encryptFileKey(fileKey, publicKey, mockPlatformAdapter);
 
       expect(result).toBe(expectedEncrypted);
       expect(
@@ -178,7 +176,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockRejectedValue(new Error("File key encryption failed"));
 
-      await expect(encryptFileKey(fileKey, publicKey)).rejects.toThrow(
+      await expect(encryptFileKey(fileKey, publicKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt file key: Error: File key encryption failed",
       );
     });
@@ -191,7 +189,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey,
       ).mockRejectedValue("Key encryption error");
 
-      await expect(encryptFileKey(fileKey, publicKey)).rejects.toThrow(
+      await expect(encryptFileKey(fileKey, publicKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt file key: Key encryption error",
       );
     });
@@ -210,7 +208,7 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const result = await getEncryptionParameters();
+      const result = await getEncryptionParameters(mockPlatformAdapter);
 
       expect(result).toHaveProperty("iv");
       expect(result).toHaveProperty("key");
@@ -224,7 +222,7 @@ describe("Additional Encryption Utils", () => {
         new Error("Key generation failed"),
       );
 
-      await expect(getEncryptionParameters()).rejects.toThrow(
+      await expect(getEncryptionParameters(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate encryption parameters: Error: Key generation failed",
       );
     });
@@ -234,7 +232,7 @@ describe("Additional Encryption Utils", () => {
         "Generation error",
       );
 
-      await expect(getEncryptionParameters()).rejects.toThrow(
+      await expect(getEncryptionParameters(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate encryption parameters: Generation error",
       );
     });
@@ -250,7 +248,7 @@ describe("Additional Encryption Utils", () => {
         mockPlatformAdapter.crypto.decryptWithPrivateKey,
       ).mockResolvedValue(expectedDecrypted);
 
-      const result = await decryptWithPrivateKey(encryptedData, privateKey);
+      const result = await decryptWithPrivateKey(encryptedData, privateKey, mockPlatformAdapter);
 
       expect(result).toBe(expectedDecrypted);
       expect(
@@ -267,7 +265,7 @@ describe("Additional Encryption Utils", () => {
       ).mockRejectedValue(new Error("DLP decryption failed"));
 
       await expect(
-        decryptWithPrivateKey(encryptedData, privateKey),
+        decryptWithPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with private key: Error: DLP decryption failed",
       );
@@ -282,7 +280,7 @@ describe("Additional Encryption Utils", () => {
       ).mockRejectedValue("DLP decryption error");
 
       await expect(
-        decryptWithPrivateKey(encryptedData, privateKey),
+        decryptWithPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with private key: DLP decryption error",
       );
@@ -300,7 +298,7 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const result = await generateEncryptionKeyPair();
+      const result = await generateEncryptionKeyPair(mockPlatformAdapter);
 
       expect(result).toEqual(mockKeyPair);
       expect(mockPlatformAdapter.crypto.generateKeyPair).toHaveBeenCalled();
@@ -311,7 +309,7 @@ describe("Additional Encryption Utils", () => {
         new Error("Crypto key generation failed"),
       );
 
-      await expect(generateEncryptionKeyPair()).rejects.toThrow(
+      await expect(generateEncryptionKeyPair(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate encryption key pair: Error: Crypto key generation failed",
       );
     });
@@ -321,7 +319,7 @@ describe("Additional Encryption Utils", () => {
         "Crypto generation error",
       );
 
-      await expect(generateEncryptionKeyPair()).rejects.toThrow(
+      await expect(generateEncryptionKeyPair(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate encryption key pair: Crypto generation error",
       );
     });
@@ -340,7 +338,7 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const result = await generatePGPKeyPair();
+      const result = await generatePGPKeyPair(mockPlatformAdapter);
 
       expect(result).toEqual(mockKeyPair);
       expect(mockPlatformAdapter.pgp.generateKeyPair).toHaveBeenCalledWith(
@@ -365,7 +363,7 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const result = await generatePGPKeyPair(options);
+      const result = await generatePGPKeyPair(mockPlatformAdapter, options);
 
       expect(result).toEqual(mockKeyPair);
       expect(mockPlatformAdapter.pgp.generateKeyPair).toHaveBeenCalledWith(
@@ -378,7 +376,7 @@ describe("Additional Encryption Utils", () => {
         new Error("PGP key generation failed"),
       );
 
-      await expect(generatePGPKeyPair()).rejects.toThrow(
+      await expect(generatePGPKeyPair(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate PGP key pair: Error: PGP key generation failed",
       );
     });
@@ -388,7 +386,7 @@ describe("Additional Encryption Utils", () => {
         "PGP generation error",
       );
 
-      await expect(generatePGPKeyPair()).rejects.toThrow(
+      await expect(generatePGPKeyPair(mockPlatformAdapter)).rejects.toThrow(
         "Failed to generate PGP key pair: PGP generation error",
       );
     });
@@ -409,7 +407,7 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const result = await generatePGPKeyPair(options);
+      const result = await generatePGPKeyPair(mockPlatformAdapter, options);
 
       expect(result).toEqual(mockKeyPair);
       expect(mockPlatformAdapter.pgp.generateKeyPair).toHaveBeenCalledWith(
@@ -436,6 +434,7 @@ describe("Additional Encryption Utils", () => {
       const encrypted = await encryptWithWalletPublicKey(
         originalData,
         publicKey,
+        mockPlatformAdapter,
       );
       expect(encrypted).toBe(encryptedData);
 
@@ -443,6 +442,7 @@ describe("Additional Encryption Utils", () => {
       const decrypted = await decryptWithWalletPrivateKey(
         encrypted,
         privateKey,
+        mockPlatformAdapter,
       );
       expect(decrypted).toBe(originalData);
     });
@@ -461,11 +461,11 @@ describe("Additional Encryption Utils", () => {
       ).mockResolvedValue(fileKey);
 
       // Encrypt file key
-      const encrypted = await encryptFileKey(fileKey, dlpPublicKey);
+      const encrypted = await encryptFileKey(fileKey, dlpPublicKey, mockPlatformAdapter);
       expect(encrypted).toBe(encryptedFileKey);
 
       // Decrypt file key (using decryptWithPrivateKey)
-      const decrypted = await decryptWithPrivateKey(encrypted, dlpPrivateKey);
+      const decrypted = await decryptWithPrivateKey(encrypted, dlpPrivateKey, mockPlatformAdapter);
       expect(decrypted).toBe(fileKey);
     });
 
@@ -481,8 +481,8 @@ describe("Additional Encryption Utils", () => {
         mockKeyPair,
       );
 
-      const params1 = await getEncryptionParameters();
-      await getEncryptionParameters();
+      const params1 = await getEncryptionParameters(mockPlatformAdapter);
+      await getEncryptionParameters(mockPlatformAdapter);
 
       // Each call should generate new parameters
       expect(params1.iv).toBe("1234567890abcdef");
diff --git a/packages/vana-sdk/src/tests/utils-encryption-wallet.test.ts b/packages/vana-sdk/src/tests/utils-encryption-wallet.test.ts
index 48d1db7..1d463f9 100644
--- a/packages/vana-sdk/src/tests/utils-encryption-wallet.test.ts
+++ b/packages/vana-sdk/src/tests/utils-encryption-wallet.test.ts
@@ -24,10 +24,7 @@ const mockPlatformAdapter: VanaPlatformAdapter = {
   platform: "node",
 };
 
-// Mock the platform module
-vi.mock("../platform", () => ({
-  getPlatformAdapter: () => mockPlatformAdapter,
-}));
+// No longer need to mock the platform module since we pass platform adapters directly
 
 describe("Wallet Encryption Utils", () => {
   beforeEach(() => {
@@ -50,7 +47,7 @@ describe("Wallet Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey as any
       ).mockResolvedValue(expectedEncryptedData);
 
-      const result = await encryptWithWalletPublicKey(testData, publicKey);
+      const result = await encryptWithWalletPublicKey(testData, publicKey, mockPlatformAdapter);
 
       expect(
         mockPlatformAdapter.crypto.encryptWithPublicKey,
@@ -69,7 +66,7 @@ describe("Wallet Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey as any
       ).mockResolvedValue(expectedEncryptedData);
 
-      await encryptWithWalletPublicKey(testData, publicKey);
+      await encryptWithWalletPublicKey(testData, publicKey, mockPlatformAdapter);
 
       expect(
         mockPlatformAdapter.crypto.encryptWithPublicKey,
@@ -87,7 +84,7 @@ describe("Wallet Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey as any
       ).mockResolvedValue(expectedEncryptedData);
 
-      await encryptWithWalletPublicKey(testData, compressedKey);
+      await encryptWithWalletPublicKey(testData, compressedKey, mockPlatformAdapter);
 
       expect(
         mockPlatformAdapter.crypto.encryptWithPublicKey,
@@ -105,7 +102,7 @@ describe("Wallet Encryption Utils", () => {
         mockPlatformAdapter.crypto.encryptWithPublicKey as any
       ).mockResolvedValue(expectedEncryptedData);
 
-      await encryptWithWalletPublicKey(testData, uncompressedKey);
+      await encryptWithWalletPublicKey(testData, uncompressedKey, mockPlatformAdapter);
 
       expect(
         mockPlatformAdapter.crypto.encryptWithPublicKey,
@@ -122,7 +119,7 @@ describe("Wallet Encryption Utils", () => {
       ).mockRejectedValue(new Error("Encryption failed"));
 
       await expect(
-        encryptWithWalletPublicKey(testData, publicKey),
+        encryptWithWalletPublicKey(testData, publicKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to encrypt with wallet public key: Error: Encryption failed",
       );
@@ -138,7 +135,7 @@ describe("Wallet Encryption Utils", () => {
       ).mockRejectedValue("Unknown error");
 
       await expect(
-        encryptWithWalletPublicKey(testData, publicKey),
+        encryptWithWalletPublicKey(testData, publicKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to encrypt with wallet public key: Unknown error",
       );
@@ -159,6 +156,7 @@ describe("Wallet Encryption Utils", () => {
       const result = await decryptWithWalletPrivateKey(
         encryptedData,
         privateKey,
+        mockPlatformAdapter,
       );
 
       expect(
@@ -177,7 +175,7 @@ describe("Wallet Encryption Utils", () => {
         mockPlatformAdapter.crypto.decryptWithPrivateKey as any
       ).mockResolvedValue(expectedDecrypted);
 
-      await decryptWithWalletPrivateKey(encryptedData, privateKey);
+      await decryptWithWalletPrivateKey(encryptedData, privateKey, mockPlatformAdapter);
 
       expect(
         mockPlatformAdapter.crypto.decryptWithPrivateKey,
@@ -201,6 +199,7 @@ describe("Wallet Encryption Utils", () => {
       const result = await decryptWithWalletPrivateKey(
         mockEncryptedData,
         privateKey,
+        mockPlatformAdapter,
       );
 
       // Verify the decryption was called and returned expected result
@@ -220,7 +219,7 @@ describe("Wallet Encryption Utils", () => {
       ).mockRejectedValue(new Error("Decryption failed"));
 
       await expect(
-        decryptWithWalletPrivateKey(encryptedData, privateKey),
+        decryptWithWalletPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with wallet private key: Error: Decryption failed",
       );
@@ -236,7 +235,7 @@ describe("Wallet Encryption Utils", () => {
       ).mockRejectedValue("Unknown error");
 
       await expect(
-        decryptWithWalletPrivateKey(encryptedData, privateKey),
+        decryptWithWalletPrivateKey(encryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with wallet private key: Unknown error",
       );
@@ -252,7 +251,7 @@ describe("Wallet Encryption Utils", () => {
       ).mockRejectedValue(new Error("Invalid encrypted data format"));
 
       await expect(
-        decryptWithWalletPrivateKey(invalidEncryptedData, privateKey),
+        decryptWithWalletPrivateKey(invalidEncryptedData, privateKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt with wallet private key: Error: Invalid encrypted data format",
       );
@@ -278,6 +277,7 @@ describe("Wallet Encryption Utils", () => {
       const encryptedData = await encryptWithWalletPublicKey(
         originalData,
         publicKey,
+        mockPlatformAdapter,
       );
 
       // Mock decryption to return original data
@@ -289,6 +289,7 @@ describe("Wallet Encryption Utils", () => {
       const decryptedData = await decryptWithWalletPrivateKey(
         encryptedData,
         privateKey,
+        mockPlatformAdapter,
       );
 
       expect(decryptedData).toBe(originalData);
diff --git a/packages/vana-sdk/src/tests/utils-encryption.test.ts b/packages/vana-sdk/src/tests/utils-encryption.test.ts
index bfc8072..cb63826 100644
--- a/packages/vana-sdk/src/tests/utils-encryption.test.ts
+++ b/packages/vana-sdk/src/tests/utils-encryption.test.ts
@@ -25,10 +25,7 @@ const mockPlatformAdapter: VanaPlatformAdapter = {
   platform: "node",
 };
 
-// Mock the platform module
-vi.mock("../platform", () => ({
-  getPlatformAdapter: () => mockPlatformAdapter,
-}));
+// No longer need to mock the platform module since we pass platform adapters directly
 
 interface MockAccount {
   address: string;
@@ -275,7 +272,7 @@ describe("Encryption Utils", () => {
         encryptedString,
       );
 
-      const result = await encryptUserData(testData, encryptionKey);
+      const result = await encryptUserData(testData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       expect(result.type).toBe("text/plain");
@@ -296,7 +293,7 @@ describe("Encryption Utils", () => {
         encryptedString,
       );
 
-      const result = await encryptUserData(emptyData, encryptionKey);
+      const result = await encryptUserData(emptyData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       expect(mockPlatformAdapter.pgp.encrypt).toHaveBeenCalledWith(
@@ -313,7 +310,7 @@ describe("Encryption Utils", () => {
         new Error("Invalid message format"),
       );
 
-      await expect(encryptUserData(testData, encryptionKey)).rejects.toThrow(
+      await expect(encryptUserData(testData, encryptionKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt user data: Error: Invalid message format",
       );
     });
@@ -326,7 +323,7 @@ describe("Encryption Utils", () => {
         new Error("Encryption failed"),
       );
 
-      await expect(encryptUserData(testData, encryptionKey)).rejects.toThrow(
+      await expect(encryptUserData(testData, encryptionKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt user data: Error: Encryption failed",
       );
     });
@@ -340,7 +337,7 @@ describe("Encryption Utils", () => {
         encryptedString,
       );
 
-      const result = await encryptUserData(testData, encryptionKey);
+      const result = await encryptUserData(testData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       const resultText = await result.text();
@@ -360,7 +357,7 @@ describe("Encryption Utils", () => {
         "String error message",
       );
 
-      await expect(encryptUserData(testData, encryptionKey)).rejects.toThrow(
+      await expect(encryptUserData(testData, encryptionKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt user data: String error message",
       );
     });
@@ -372,7 +369,7 @@ describe("Encryption Utils", () => {
       // Mock a rejection with null/undefined
       vi.mocked(mockPlatformAdapter.pgp.encrypt).mockRejectedValue(null);
 
-      await expect(encryptUserData(testData, encryptionKey)).rejects.toThrow(
+      await expect(encryptUserData(testData, encryptionKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt user data: null",
       );
     });
@@ -387,7 +384,7 @@ describe("Encryption Utils", () => {
         reason: "Server error",
       });
 
-      await expect(encryptUserData(testData, encryptionKey)).rejects.toThrow(
+      await expect(encryptUserData(testData, encryptionKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to encrypt user data: [object Object]",
       );
     });
@@ -403,7 +400,7 @@ describe("Encryption Utils", () => {
         decryptedString,
       );
 
-      const result = await decryptUserData(encryptedData, encryptionKey);
+      const result = await decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       expect(result.type).toBe("text/plain");
@@ -424,7 +421,7 @@ describe("Encryption Utils", () => {
         decryptedString,
       );
 
-      const result = await decryptUserData(emptyEncryptedData, encryptionKey);
+      const result = await decryptUserData(emptyEncryptedData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       const resultText = await result.text();
@@ -440,7 +437,7 @@ describe("Encryption Utils", () => {
       );
 
       await expect(
-        decryptUserData(encryptedData, encryptionKey),
+        decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter),
       ).rejects.toThrow(
         "Failed to decrypt user data: Error: Invalid encrypted message",
       );
@@ -455,7 +452,7 @@ describe("Encryption Utils", () => {
         decryptedString,
       );
 
-      const result = await decryptUserData(encryptedData, encryptionKey);
+      const result = await decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter);
 
       expect(result).toBeInstanceOf(Blob);
       const resultText = await result.text();
@@ -474,7 +471,7 @@ describe("Encryption Utils", () => {
         new Error("Session key decryption failed"),
       );
 
-      await expect(decryptUserData(encryptedData, wrongKey)).rejects.toThrow(
+      await expect(decryptUserData(encryptedData, wrongKey, mockPlatformAdapter)).rejects.toThrow(
         "Failed to decrypt user data: Error: Session key decryption failed",
       );
     });
@@ -489,7 +486,7 @@ describe("Encryption Utils", () => {
       );
 
       await expect(
-        decryptUserData(encryptedData, encryptionKey),
+        decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter),
       ).rejects.toThrow("Failed to decrypt user data: Decryption string error");
     });
 
@@ -501,7 +498,7 @@ describe("Encryption Utils", () => {
       vi.mocked(mockPlatformAdapter.pgp.decrypt).mockRejectedValue(undefined);
 
       await expect(
-        decryptUserData(encryptedData, encryptionKey),
+        decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter),
       ).rejects.toThrow("Failed to decrypt user data: undefined");
     });
 
@@ -516,7 +513,7 @@ describe("Encryption Utils", () => {
       });
 
       await expect(
-        decryptUserData(encryptedData, encryptionKey),
+        decryptUserData(encryptedData, encryptionKey, mockPlatformAdapter),
       ).rejects.toThrow("Failed to decrypt user data: [object Object]");
     });
   });
@@ -539,12 +536,12 @@ describe("Encryption Utils", () => {
       );
 
       // Test workflow
-      const encrypted = await encryptUserData(originalData, encryptionKey);
+      const encrypted = await encryptUserData(originalData, encryptionKey, mockPlatformAdapter);
       expect(encrypted).toBeInstanceOf(Blob);
       const encryptedText = await encrypted.text();
       expect(encryptedText).toBe(encryptedString);
 
-      const decrypted = await decryptUserData(encrypted, encryptionKey);
+      const decrypted = await decryptUserData(encrypted, encryptionKey, mockPlatformAdapter);
       expect(decrypted).toBeInstanceOf(Blob);
       const decryptedText = await decrypted.text();
       expect(decryptedText).toBe(originalDataText);
@@ -563,8 +560,8 @@ describe("Encryption Utils", () => {
         originalDataText,
       );
 
-      const encrypted = await encryptUserData(largeData, encryptionKey);
-      const decrypted = await decryptUserData(encrypted, encryptionKey);
+      const encrypted = await encryptUserData(largeData, encryptionKey, mockPlatformAdapter);
+      const decrypted = await decryptUserData(encrypted, encryptionKey, mockPlatformAdapter);
 
       expect(encrypted).toBeInstanceOf(Blob);
       expect(decrypted).toBeInstanceOf(Blob);
diff --git a/packages/vana-sdk/src/tests/vana.test.ts b/packages/vana-sdk/src/tests/vana.test.ts
index cf72d43..65d7624 100644
--- a/packages/vana-sdk/src/tests/vana.test.ts
+++ b/packages/vana-sdk/src/tests/vana.test.ts
@@ -2,9 +2,10 @@ import { describe, it, expect, vi, beforeEach } from "vitest";
 import { createWalletClient, http, type WalletClient } from "viem";
 import { privateKeyToAccount } from "viem/accounts";
 import { mokshaTestnet } from "../config/chains";
-import { Vana } from "../vana";
+import { VanaSDKCore } from "../core";
 import { InvalidConfigurationError } from "../errors";
 import { type VanaChain, type VanaConfig, type WalletConfig } from "../types";
+import { mockPlatformAdapter } from "./mocks/platformAdapter";
 
 // Mock the controllers
 vi.mock("../controllers/permissions", () => ({
@@ -44,7 +45,7 @@ const testAccount = privateKeyToAccount(
   "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
 );
 
-describe("Vana", () => {
+describe("VanaSDKCore", () => {
   let validWalletClient: WalletClient & { chain: VanaChain };
 
   beforeEach(() => {
@@ -59,13 +60,13 @@ describe("Vana", () => {
 
   describe("Constructor", () => {
     it("should initialize successfully with valid config", () => {
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
         relayerCallbacks: {
           submitPermissionGrant: async (_typedData, _signature) => "0xtxhash",
           submitPermissionRevoke: async (_typedData, _signature) => "0xtxhash",
         },
-      });
+      }, mockPlatformAdapter);
 
       expect(vana).toBeDefined();
       expect(vana.permissions).toBeDefined();
@@ -74,63 +75,63 @@ describe("Vana", () => {
     });
 
     it("should work without relayer callbacks (direct transaction mode)", () => {
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
-      });
+      }, mockPlatformAdapter);
 
       expect(vana.getConfig().relayerCallbacks).toBeUndefined();
     });
 
     it("should throw InvalidConfigurationError when config is missing", () => {
       expect(() => {
-        new Vana(null as unknown as VanaConfig);
+        new VanaSDKCore(null as unknown as VanaConfig, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
 
     it("should throw InvalidConfigurationError when walletClient is missing", () => {
       expect(() => {
-        new Vana({} as unknown as VanaConfig);
+        new VanaSDKCore({} as unknown as VanaConfig, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
 
     it("should throw InvalidConfigurationError when walletClient is invalid", () => {
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient: {} as unknown as typeof validWalletClient,
-        });
+        }, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
 
     it("should throw InvalidConfigurationError when relayerCallbacks is invalid", () => {
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient: validWalletClient,
           relayerCallbacks: "not-an-object" as unknown as Record<
             string,
             unknown
           >,
-        });
+        }, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
 
     it("should work with partial relayerCallbacks", () => {
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient: validWalletClient,
           relayerCallbacks: {
             submitPermissionGrant: async (_typedData, _signature) => "0xtxhash",
             // Only one callback provided - should still work
           },
-        });
+        }, mockPlatformAdapter);
       }).not.toThrow();
     });
 
     it("should work with empty relayerCallbacks object", () => {
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient: validWalletClient,
           relayerCallbacks: {},
-        });
+        }, mockPlatformAdapter);
       }).not.toThrow();
     });
 
@@ -147,10 +148,10 @@ describe("Vana", () => {
       });
 
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient:
             invalidChainClient as unknown as WalletConfig["walletClient"],
-        } as WalletConfig);
+        } as WalletConfig, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
 
@@ -161,19 +162,19 @@ describe("Vana", () => {
       };
 
       expect(() => {
-        new Vana({
+        new VanaSDKCore({
           walletClient:
             noChainClient as unknown as WalletConfig["walletClient"],
-        } as WalletConfig);
+        } as WalletConfig, mockPlatformAdapter);
       }).toThrow(InvalidConfigurationError);
     });
   });
 
   describe("Properties", () => {
-    let vana: Vana;
+    let vana: VanaSDKCore;
 
     beforeEach(() => {
-      vana = new Vana({
+      vana = new VanaSDKCore({
         walletClient: validWalletClient,
         relayerCallbacks: {
           submitPermissionGrant: async (_typedData, _signature) => "0xtxhash",
@@ -198,10 +199,10 @@ describe("Vana", () => {
   });
 
   describe("Methods", () => {
-    let vana: Vana;
+    let vana: VanaSDKCore;
 
     beforeEach(() => {
-      vana = new Vana({
+      vana = new VanaSDKCore({
         walletClient: validWalletClient,
         relayerCallbacks: {
           submitPermissionGrant: async (_typedData, _signature) => "0xtxhash",
@@ -238,13 +239,13 @@ describe("Vana", () => {
 
   describe("Integration", () => {
     it("should pass shared context to all controllers", () => {
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
         relayerCallbacks: {
           submitPermissionGrant: async (_typedData, _signature) => "0xtxhash",
           submitPermissionRevoke: async (_typedData, _signature) => "0xtxhash",
         },
-      });
+      }, mockPlatformAdapter);
 
       // Verify that controllers are initialized with the correct context
       expect(vana.permissions).toBeDefined();
@@ -272,7 +273,7 @@ describe("Vana", () => {
         getConfig: vi.fn().mockReturnValue({ name: "Mock Provider" }),
       };
 
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
         storage: {
           providers: {
@@ -305,7 +306,7 @@ describe("Vana", () => {
         getConfig: vi.fn().mockReturnValue({ name: "Mock Provider 2" }),
       };
 
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
         storage: {
           providers: {
@@ -329,9 +330,9 @@ describe("Vana", () => {
     });
 
     it("should work without storage configuration", async () => {
-      const vana = new Vana({
+      const vana = new VanaSDKCore({
         walletClient: validWalletClient,
-      });
+      }, mockPlatformAdapter);
 
       expect(vana).toBeDefined();
       // StorageManager should not be called when no storage config
@@ -340,7 +341,7 @@ describe("Vana", () => {
       const callCount = MockedStorageManager.mock.calls.length;
 
       // Create another instance to verify StorageManager isn't called again
-      new Vana({
+      new VanaSDKCore({
         walletClient: validWalletClient,
       });
 
diff --git a/packages/vana-sdk/src/utils/encryption.ts b/packages/vana-sdk/src/utils/encryption.ts
index d55bd15..551a27a 100644
--- a/packages/vana-sdk/src/utils/encryption.ts
+++ b/packages/vana-sdk/src/utils/encryption.ts
@@ -9,7 +9,7 @@
  * encryption functionality across Node.js and browser environments.
  */
 
-import { getPlatformAdapter } from "../platform";
+import type { VanaPlatformAdapter } from "../platform/interface";
 import type { WalletClient } from "viem";
 
 /**
@@ -49,14 +49,15 @@ export async function generateEncryptionKey(
  * Encrypt data with a wallet's public key using platform-appropriate cryptography
  * @param data The data to encrypt (as string or Blob)
  * @param publicKey The public key for encryption
+ * @param platformAdapter The platform adapter to use for encryption
  * @returns The encrypted data
  */
 export async function encryptWithWalletPublicKey(
   data: string | Blob,
   publicKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<string> {
   try {
-    const platformAdapter = getPlatformAdapter();
     const dataString = data instanceof Blob ? await data.text() : data;
     return await platformAdapter.crypto.encryptWithPublicKey(
       dataString,
@@ -71,14 +72,15 @@ export async function encryptWithWalletPublicKey(
  * Decrypt data with a wallet's private key using platform-appropriate cryptography
  * @param encryptedData The encrypted data
  * @param privateKey The private key for decryption
+ * @param platformAdapter The platform adapter to use for decryption
  * @returns The decrypted data as string
  */
 export async function decryptWithWalletPrivateKey(
   encryptedData: string,
   privateKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<string> {
   try {
-    const platformAdapter = getPlatformAdapter();
     return await platformAdapter.crypto.decryptWithPrivateKey(
       encryptedData,
       privateKey,
@@ -92,14 +94,15 @@ export async function decryptWithWalletPrivateKey(
  * Encrypt a file key with a DLP's public key using platform-appropriate cryptography
  * @param fileKey The symmetric key used to encrypt the file
  * @param publicKey The DLP's public key
+ * @param platformAdapter The platform adapter to use for encryption
  * @returns The encrypted key that can be stored on-chain
  */
 export async function encryptFileKey(
   fileKey: string,
   publicKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<string> {
   try {
-    const platformAdapter = getPlatformAdapter();
     return await platformAdapter.crypto.encryptWithPublicKey(
       fileKey,
       publicKey,
@@ -111,15 +114,16 @@ export async function encryptFileKey(
 
 /**
  * Generate encryption parameters for secure file storage
+ * @param platformAdapter The platform adapter to use for key generation
  * @returns An object containing the initialization vector and encryption key
  */
-export async function getEncryptionParameters(): Promise<{
+export async function getEncryptionParameters(
+  platformAdapter: VanaPlatformAdapter,
+): Promise<{
   iv: string;
   key: string;
 }> {
   try {
-    const platformAdapter = getPlatformAdapter();
-
     // Generate a new key pair for encryption parameters
     const keyPair = await platformAdapter.crypto.generateKeyPair();
 
@@ -138,14 +142,15 @@ export async function getEncryptionParameters(): Promise<{
  * Decrypt data that was encrypted with the DLP's public key using platform-appropriate cryptography
  * @param encryptedData The encrypted data
  * @param privateKey The private key corresponding to the public key used for encryption
+ * @param platformAdapter The platform adapter to use for decryption
  * @returns The decrypted data
  */
 export async function decryptWithPrivateKey(
   encryptedData: string,
   privateKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<string> {
   try {
-    const platformAdapter = getPlatformAdapter();
     return await platformAdapter.crypto.decryptWithPrivateKey(
       encryptedData,
       privateKey,
@@ -159,14 +164,15 @@ export async function decryptWithPrivateKey(
  * Encrypt user data using PGP with platform-appropriate configuration
  * @param data The data to encrypt (string or Blob)
  * @param publicKey The PGP public key
+ * @param platformAdapter The platform adapter to use for encryption
  * @returns The encrypted data as Blob
  */
 export async function encryptUserData(
   data: string | Blob,
   publicKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<Blob> {
   try {
-    const platformAdapter = getPlatformAdapter();
     const dataString = data instanceof Blob ? await data.text() : data;
     const encryptedString = await platformAdapter.pgp.encrypt(
       dataString,
@@ -182,14 +188,15 @@ export async function encryptUserData(
  * Decrypt user data using PGP with platform-appropriate configuration
  * @param encryptedData The encrypted data (string or Blob)
  * @param privateKey The PGP private key
+ * @param platformAdapter The platform adapter to use for decryption
  * @returns The decrypted data as Blob
  */
 export async function decryptUserData(
   encryptedData: string | Blob,
   privateKey: string,
+  platformAdapter: VanaPlatformAdapter,
 ): Promise<Blob> {
   try {
-    const platformAdapter = getPlatformAdapter();
     const dataString =
       encryptedData instanceof Blob
         ? await encryptedData.text()
@@ -206,14 +213,16 @@ export async function decryptUserData(
 
 /**
  * Generate a new key pair for asymmetric encryption
+ * @param platformAdapter The platform adapter to use for key generation
  * @returns Promise resolving to public and private key pair
  */
-export async function generateEncryptionKeyPair(): Promise<{
+export async function generateEncryptionKeyPair(
+  platformAdapter: VanaPlatformAdapter,
+): Promise<{
   publicKey: string;
   privateKey: string;
 }> {
   try {
-    const platformAdapter = getPlatformAdapter();
     return await platformAdapter.crypto.generateKeyPair();
   } catch (error) {
     throw new Error(`Failed to generate encryption key pair: ${error}`);
@@ -222,16 +231,19 @@ export async function generateEncryptionKeyPair(): Promise<{
 
 /**
  * Generate a new PGP key pair with platform-appropriate configuration
+ * @param platformAdapter The platform adapter to use for key generation
  * @param options Key generation options
  * @returns Promise resolving to public and private key pair
  */
-export async function generatePGPKeyPair(options?: {
-  name?: string;
-  email?: string;
-  passphrase?: string;
-}): Promise<{ publicKey: string; privateKey: string }> {
+export async function generatePGPKeyPair(
+  platformAdapter: VanaPlatformAdapter,
+  options?: {
+    name?: string;
+    email?: string;
+    passphrase?: string;
+  },
+): Promise<{ publicKey: string; privateKey: string }> {
   try {
-    const platformAdapter = getPlatformAdapter();
     return await platformAdapter.pgp.generateKeyPair(options);
   } catch (error) {
     throw new Error(`Failed to generate PGP key pair: ${error}`);
diff --git a/packages/vana-sdk/src/vana.ts b/packages/vana-sdk/src/vana.ts
index 980b5d5..de6fabd 100644
--- a/packages/vana-sdk/src/vana.ts
+++ b/packages/vana-sdk/src/vana.ts
@@ -19,6 +19,7 @@ import { StorageManager, StorageProvider } from "./storage";
 import { createWalletClient, createPublicClient, http } from "viem";
 import { chains } from "./config/chains";
 import { getChainConfig } from "./chains";
+import type { VanaPlatformAdapter } from "./platform/interface";
 
 /**
  * The main Vana SDK client class.
@@ -103,6 +104,7 @@ export class Vana {
 
   private readonly relayerCallbacks?: RelayerCallbacks;
   private readonly storageManager?: StorageManager;
+  private readonly platform: VanaPlatformAdapter;
 
   /**
    * Creates a Vana SDK instance from a chain configuration.
@@ -179,6 +181,9 @@ export class Vana {
     // Validate configuration
     this.validateConfig(config);
 
+    // Detect and initialize platform adapter
+    this.platform = this.detectPlatform();
+
     // Store relayer callbacks if provided
     this.relayerCallbacks = config.relayerCallbacks;
 
@@ -256,6 +261,7 @@ export class Vana {
       relayerCallbacks: this.relayerCallbacks,
       storageManager: this.storageManager,
       subgraphUrl,
+      platform: this.platform,
     };
 
     // Initialize controllers
@@ -424,4 +430,18 @@ export class Vana {
       defaultStorageProvider: this.storageManager?.getDefaultStorageProvider(),
     };
   }
+
+  /**
+   * Detects the current platform and returns the appropriate adapter.
+   * This is a fallback for backward compatibility.
+   * 
+   * @deprecated Use the environment-specific entry points instead: 
+   * import { VanaSDK } from 'vana-sdk' (automatically detects environment)
+   */
+  private detectPlatform(): VanaPlatformAdapter {
+    throw new Error(
+      "Platform detection is deprecated. Use environment-specific entry points: " +
+      "import { VanaSDK } from 'vana-sdk' which automatically uses the correct adapter for your environment."
+    );
+  }
 }
diff --git a/packages/vana-sdk/tsconfig.json b/packages/vana-sdk/tsconfig.json
index 822df91..62022ca 100644
--- a/packages/vana-sdk/tsconfig.json
+++ b/packages/vana-sdk/tsconfig.json
@@ -21,7 +21,6 @@
     "noImplicitOverride": true,
     "skipLibCheck": true,
     "types": ["node"],
-    "rootDir": "./src",
     "resolveJsonModule": true,
     "isolatedModules": true,
     "verbatimModuleSyntax": false,
@@ -30,6 +29,6 @@
     "incremental": true,
     "tsBuildInfoFile": ".tsbuildinfo"
   },
-  "include": ["src/**/*.ts", "src/**/*.json"],
+  "include": ["src/**/*.ts", "src/**/*.json", "tsup.config.ts"],
   "exclude": ["node_modules", "dist", "**/dist", "examples/**/*", "coverage/**/*", "test-dist"]
 }
